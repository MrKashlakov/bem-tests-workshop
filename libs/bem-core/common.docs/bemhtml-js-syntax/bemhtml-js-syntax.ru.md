# JS-синтаксис BEMHTML. Руководство по миграции

<a name="intro"></a>
## Введение

Документ предназначен для веб-разработчиков и HTML-верстальщиков, использующих [БЭМ-методологию](https://ru.bem.info/method/) и [шаблонизатор BEMHTML](https://ru.bem.info/libs/bem-core/current/bemhtml/reference/).

В документе описаны:

* [совместимость](#compat) BEMHTML-шаблонов, реализованных в разном синтаксисе;
* настройки [среды исполнения шаблонов](#runmode);
* схема [обработки BEMHTML-шаблонов](#run);
* реализация в [JavaScript-синтаксисе](#syntax) стандартных операций шаблонизатора BEMHTML;
* [алгоритм преобразования](#steps) шаблонов из сокращенного в JS-синтаксис.

В документе не описаны настройка среды разработки и процедуры компиляции шаблонов, особенности шаблонизатора BEMHTML, формат входных данных [BEMJSON](https://ru.bem.info/technology/bemjson/current/bemjson/).


<a name="general"></a>
## Общие сведения

С версии v1.0.0 в библиотеку [bem-core](https://ru.bem.info/libs/bem-core/) была добавлена возможность исполнять BEMHTML-шаблоны, написанные в JavaScript-синтаксисе.

В библиотеке поддерживается два вида синтаксиса шаблонов: **сокращенный** и JS-синтаксис. С момента выпуска библиотеки bem-core сокращенный синтаксис шаблонов считается устаревшим.

JavaScript-синтаксис BEMHTML-шаблонов имеет следующие преимущества:

* Поддержку синтаксиса различными средами разработки и инструментами (т.к. код — обычный JavaScript):
  * подсветка кода;
  * JSHint, JSLint и т.д.
* Более высокую скорость [компиляции](#runpre), особенно в dev-среде исполнения.
* Кроме того, код шаблонов может выполняться непосредственно в [dev-среде исполнения](#runmode), что упрощает поиск ошибок и отладку.

При использовании JS-синтаксиса шаблонов сохраняются все ключевые особенности шаблонизатора BEMHTML.


<a name="install"></a>
## Начало работы

Возможность исполнения BEMHTML-шаблонов с JS-синтаксисом доступна во всех компонентах БЭМ-платформы, использующих библиотеку bem-core.

Для перехода на JS-синтаксис можно:

* воспользоваться версией project-stub, использующей библиотеку bem-core (ветка [bem-core](https://github.com/bem/project-stub/tree/bem-core));
* самостоятельно установить необходимые пакеты — [bem-xjst](https://ru.bem.info/tools/templating-engines/bemxjst/), модуль технологии пакета [enb-bemxjst](https://ru.bem.info/tools/bem/enb-bemxjst/).


<a name="compat"></a>
## Совместимость шаблонов

BEMHTML-шаблоны, реализованные в разном синтаксисе, могут использоваться в одном проекте.

В процессе выполнения шаблонизатор приводит шаблоны, написанные в сокращенном синтаксисе, к JS-синтаксису. Синтаксическое преобразование производит модуль [bemhtml-compat](https://github.com/bem/bemhtml-compat). Подробнее об этом читайте в разделе про [выполнение шаблонов](#runmain).

В ходе компиляции шаблонизатор автоматически определяет синтаксис, в котором реализован файл шаблона.

Чтобы различать файлы шаблонов, реализованных в сокращенном и в JS-синтаксисе, можно использовать для них разные суффиксы:

 * для сокращенного синтаксиса  — суффикс `.bemhtml`;
 * для JS-синтаксиса  — суффикс `.bemhtml.xjst`.


**NB** Нельзя использовать в файле шаблона оба синтаксиса одновременно.


<a name="syntax"></a>
## JavaScript-cинтаксис BEMHTML-шаблонов

Чтобы упростить создание BEMHTML-шаблонов с JavaScript-синтаксисом, используется модуль [bem-xjst](https://ru.bem.info/tools/templating-engines/bemxjst/).

BEM-XJST — это набор БЭМ-ориентированных хелперов, расширяющий стандартный XJST-синтаксис.

Для BEMHTML-шаблонов в JS-синтаксисе он позволяет использовать:

  * хелперы для записи подпредикатов, относящихся к предметной области БЭМ;
  * хелперы для определения подпредиката по моде;
  * хелперы для применения XJST-конструкций `apply` и `applyNext` по произвольной моде;
  * конструкцию [applyCtx](https://ru.bem.info/technology/bemhtml/current/templating/#applyctx).


BEM-XJST является надмножеством [языка шаблонов XJST](https://github.com/veged/xjst), который, в свою очередь, является надмножеством JavaScript.

BEM-XJST использует канонический XJST-синтаксис, расширенный набором правил, относящихся к предметной области БЭМ. Такая реализация позволяет выполнять BEMHTML-шаблоны, написанные в JS-синтаксисе, в dev-среде без предварительной компиляции.

**NB** Поведение методов `apply` и `applyNext` в BEM-XJST расширено относительно XJST. Методы могут принимать строковый литерал или выражение, приводимое к строке, вместо выражений присвоения. Это означает «выставить указанную строку в качестве моды».

Например, выражение ``apply('content')`` эквивалентно выражению ``apply({ _mode: 'content' })``.


<a name="template"></a>

#### Шаблон

Шаблон состоит из двух выражений — **предиката** и **тела**.
Каждый **предикат** представляет собой список из одного или более **подпредикатов** (условий).

Предикат шаблона истинен только тогда, когда истинны все подпредикаты.

В сокращенном синтаксисе предикат и тело разделяются двоеточием, а подпредикаты — запятыми:

```
подпредикат1, подпредикат2, подпредикат3: тело
```

В JS-синтаксисе для описания шаблона вводится ключевое слово `match`.

Ключевое слово `match` — это метод-хелпер, принимающий в качестве аргумента перечень подпредикатов. Метод возвращает функцию, принимающую аргументом тело шаблона.

```js
match(подпредикат1, подпредикат2, подпредикат3)(тело);
```

Например:

```js
match(function() { return this.block === 'link'; }, function() { return this._mode === 'tag'; }, function() { return this.ctx.url; })('a');
```

Тот же набор подпредикатов может быть записан цепочкой:

```js
match(function() { return this.block === 'link'; })
.match(function() { return this._mode === 'tag'; })
.match(function() { return this.ctx.url; })('a');
```

Приведенные выше примеры тождественны и соответствуют следующей записи в сокращенном синтаксисе:

```
block link, tag, this.ctx.url: 'a'
```

----
**NB** Если для данного контекста определено более одного шаблона, то больший приоритет имеет **последний** в порядке перечисления в BEMHTML-файле.

Более специфические шаблоны должны располагаться в тексте ниже, чем более общие.
***


<a name="subpredicate"></a>

#### Подпредикаты

Предикат шаблона представляет собой набор условий, описывающих момент применения шаблона. Подпредикат шаблона соответствует элементарному условию.

В BEMHTML предусмотрены следующие типы условий:

* Совпадение с входным БЭМ-деревом;
* Мода;
* Произвольное условие.


##### Совпадение с входным БЭМ-деревом
Условия совпадения с входным БЭМ-деревом позволяют описывать применимость шаблона в терминах БЭМ-сущностей: имен блоков и элементов, имен и значений модификаторов.

Для БЭМ-сущностей в предикатах используются следующие ключевые слова:

***
БЭМ-сущность — **Блок**.
***

Ключевое слово — `block`.

Аргументы:
* имя блока.

Пример в сокращенном синтаксисе:
`block b-menu` или `block 'b-menu'` или `block 'b' + '-menu'`


Пример в JS-синтаксисе:
`block('b-menu')` или `block('b' + '-menu')`


***


БЭМ-сущность — **Элемент**.
***

Ключевое слово — `elem`.


Аргументы:
* имя элемента.

Пример в сокращенном синтаксисе:
```
block b-menu, elem item
```

Пример в JS-синтаксисе:
```js
block('b-menu').elem('item')
```
***


БЭМ-сущность — **Модификатор блока**.
***

Ключевое слово — `mod`.

Аргументы:
* имя модификатора блока;
* значение модификатора блока.

Пример в сокращенном синтаксисе:
```
block b-head-logo, mod size big
```

Пример в JS-синтаксисе:
```js
block('b-head-logo').mod('size', 'big')
```
***


БЭМ-сущность — **Модификатор элемента**.
***
Ключевое слово в сокращенном синтаксисе — `elemMod`.
Ключевое слово в JS-синтаксисе — `elemMod`.

Аргументы:
* имя модификатора элемента;
* значение модификатора элемента.

Пример в сокращенном синтаксисе:
```
block b-head-logo, elem text, elemMod size big
```

Пример в JS-синтаксисе:
```js
block('b-head-logo')(elem('text').elemMod('size', 'big'))
```

***


**NB** Идентификаторы блоков, элементов, модификаторов и их значений представляют собой строку, состоящую из латинских символов и дефиса. Вместо идентификатора может быть указано любое JS-выражение, которое будет приведено к строке. Например, запись `block('b-head-logo')` тождественна записи `block('b-' + 'head' + '-logo')`.

В JS-синтаксисе ключевые слова, относящиеся к БЭМ-предметной области, используются для сокращенной записи подпредикатов.
В частности, они избавляют от необходимости использовать ключевое слово `match` в БЭМ-ориентированных подпредикатах.

Следующие предикаты тождественны:

```js
match(function() { return this.block === 'foo'; }).match(function() { this.elem === 'bar'; })
```

```js
block('foo').elem('bar')
```


Чтобы шаблоны выполнялись без компиляции, было добавлено ключевое слово `elemMatch`. Оно используется при записи произвольного подпредиката для элемента:

```js
block('my-block')
    .elemMatch(function() { return this.elem === 'e1' || this.elem === 'e2'  })
        .tag()('span')
```
Дело в том, что в процессе обработки к шаблонам, у которых нет подпредикатов, описывающих элементы, автоматически добавляется
подпредикат `!this.elem`. Это позволяет избежать срабатывания шаблонов для блока на элементах этого же блока.

Как следствие, приведенный выше пример, записанный без `elemMatch`, работать не будет:

```js
block('my-block')
    .match(function() { return this.elem === 'e1' || this.elem === 'e2'  })
        .tag()('span')
```

Ведь в процессе обработки к нему будет добавлен подпредикат  `!this.elem`.


***


<a name="moda"></a>

##### Мода

В качестве подпредиката может выступать название одной из [стандартных мод](https://ru.bem.info/technology/bemhtml/current/reference/#standardmoda). Это означает, что данный предикат будет истинным в тот момент обработки, когда выставлена соответствующая мода.

Для проверки стандартных мод используются ключевые слова:

* `def`
* `tag`
* `attrs`
* `bem`
* `mix`
* `cls`
* `js`
* `jsAttr`
* `content`

В JS-синтаксисе, чтобы определить подпредикат по одной из стандартных мод, можно воспользоваться хелпером, соответствующим ключевому слову.

Например, выражение ``tag()('span')`` эквивалентно выражению ``match(function() { return this._mode === 'tag'; })('span')``.

В сокращенном синтаксисе любой подпредикат, состоящий только из идентификатора (`[a-zA-Z0-9-]+`), интерпретируется как название нестандартной моды. Например, подпредикат `my-mode` эквивалентен подпредикату ``this._mode === 'my-mode'``.


В JS-синтаксисе для определения подпредиката по нестандартной моде вводится ключевое слово `mode`. Это метод-хелпер, действующий аналогично конструкции `match`. Метод принимает аргументом строку — название нестандартной моды - и возвращает функцию от одного аргумента — тела шаблона. Таким образом, запись `mode('my-mode')` эквивалентна записи ``this._mode === 'my-mode'``.


##### Произвольное условие
<a name="arbitrary_condition"></a>

Произвольные условия учитывают совпадения с данными, не попадающими под предметную область БЭМ. В качестве произвольного
условия может выступать любое JavaScript-выражение, которое будет приведено к логическому значению.

***
**NB** Произвольные условия предпочтительно записывать в <a name="xjst-canonical"></a> **канонической форме XJST**:

```
предикатное выражение === значение
```

Где

* `предикатное выражение` — произвольное JavaScript-выражение, приводимое к логическому значению;
* `значение` — произвольное JavaScript-выражение.


В JS-синтаксисе для записи произвольного предикатного выражения используется ключевое слово `match`. Например:

```js
match(this.ctx.url)(
        tag()('a'), // в моде tag передает аргументом строку с тэгом  'a'
        attrs()({ href: this.ctx.url }) // в моде attrs передает аргументом хеш с атрибутами
    )
```

Произвольный подпредикат `this.ctx.url` будет истинен, когда полю `url` в контексте присвоено значение. В этом случае будет выполнено тело шаблона.


***

<a name="body"></a>

#### Тело

Тело шаблона представляет собой выражение, результат вычисления которого используется для генерации выходного HTML.
В качестве тела шаблона может выступать:

* Отдельное JavaScript-выражение:
  * сокращенный синтаксис:
```
предикат: JS-выражение
```

  * JS-синтаксис:
```js
match(предикат)(JS-выражение)
```

* Блок JavaScript-кода:
  * сокращенный синтаксис:
```
предикат: { JS-код }
```

  * JS-синтаксис:
```js
match(предикат)(function() { JS-код })
```


В JS-синтаксисе тело шаблона передается аргументом в функцию, возвращаемую методом `match` и хелперами для БЭМ-сущности или моды.

Синтаксис:

```
стандартная-мода()(тело)

mode('нестандартная-мода')(тело)

БЭМ-сущность('имя-сущности')(тело)

match(произвольный предикат)(тело)
```


**NB** Важно помнить, что тело шаблона передается в функцию, возвращаемую методом-хелпером, а не в сам хелпер.

Неправильно:
```js
block('b1').tag('span')
```

Правильно:

```js
block('b1').tag()('span')
```

#### Конструкции XJST
В шаблонах, реализованных в JS-синтаксисе, могут использоваться [конструкции языка XJST](https://ru.bem.info/technology/bemhtml/current/templating/#unity) для выполнения шаблонов в измененном контексте.

Они работают так же, как и в шаблонах, реализованных в сокращенном синтаксисе.


#### Вложенность шаблонов

Если несколько шаблонов имеют общие подпредикаты, они могут быть записаны в виде вложенной структуры для сокращения количества повторов в коде.

В сокращенном синтаксисе для обозначения вложенности используются фигурные скобки. Фигурные скобки ставятся после общей части предикатов. В них заключается блок кода, содержащий различающиеся части предикатов и соответствующие им тела шаблонов.

```
подпредикат1 {
  подпредикат2: тело1
  подпредикат3: тело2
}
```

Данная запись эквивалентна следующей:

```
подпредикат 1, подпредикат 2: тело1
подпредикат 1, подпредикат 3: тело2
```

В JS-синтаксисе вложенные подпредикаты записываются в тело шаблона.  Иначе говоря, подпредикаты передаются аргументами функции, возвращаемой методом `match` и хелперами для БЭМ-сущностей или мод.

Например, шаблон в сокращенном синтаксисе:

```js
this.block === 'link' {
    this._mode === 'tag': 'a'
    this._mode === 'attrs': { href: this.ctx.url }
}
```

может быть записан в виде:

```js
match(function() { return this.block === 'link'; })(
   match(function() { return this._mode === 'tag'; })('a'),
   match(function() { return this._mode === 'attrs'; })(function() { return { href: this.ctx.url }; })
)
```


Это эквивалентно следующей записи:

```js
match(function() { return this.block === 'link'; }).match(function() { return this._mode === 'tag'; })('a');
match(function() { return this.block === 'link'; }).match(function() { return this._mode === 'attrs'; })(function() { return { href: this.ctx.url }; });
```


Чтобы сделать запись более лаконичной, можно использовать хелперы для БЭМ-сущностей и названий стандартных мод.


Предыдущий пример может быть записан в виде:

```js
block('link')(
    tag()('a'),
    attrs()(function() { return { href: this.ctx.url }; })
)
```


В BEMHTML-шаблонах на одном уровне вложенности могут находиться тело шаблона и подшаблоны.

В сокращенном синтаксисе для реализации такой возможности использовалось ключевое слово `true`:

```
block link, tag, this.ctx.url {
    true: 'a'
    mods not-link yes: 'span'
}
```

В JS-синтаксисе тело шаблона передается функции, возвращаемой хелпером, первым аргументом, а подшаблоны — следующими:

```js
block('link').tag().match(function() { return this.ctx.url; })(
    'a',
    mod('not-link', 'yes')('span')
)
```

Глубина вложенности подшаблонов не ограничена:

```js
block('link')(
    tag()('span'),
    match(function() { return this.ctx.url; })(
        tag()('a'),
        attrs()(function() { return { href: this.ctx.url }; })
    )
)
```

**NB** Не рекомендуется использовать для записи вложенных подшаблонов тернарный оператор или условные операторы JavaScript. Такая запись не будет оптимизированна в продакшн-среде исполнения.


<a name="runmode"></a>
## Среда исполнения шаблонов

Шаблонизатор BEMHTML может работать в двух режимах, в зависимости от настроек **среды исполнения**. Шаблонизатор поддерживает две среды исполнения:

* cреда разработки (dev-среда);
* продакшн-среда.


Основная разница заключается в том, что в продакшн-среде производятся XJST-преобразования шаблонов, в результате которых получается оптимизированный JavaScript. Это увеличивает время сборки проекта за счет компиляции шаблонов, но в дальнейшем повышает скорость их выполнения.

Среда исполнения устанавливается шаблонизатором на основании значения переменной окружения `process.env.BEMHTML_ENV`. При значении равном `'development'` используется среда разработки. Во всех остальных случаях используется продакшн-среда.

Выбор среды исполнения влияет на ход выполнения шаблонов, реализованных как в сокращенном, так и в JS- синтаксисах.


<a name="run"></a>
## Обработка BEMHTML-шаблонов

Шаблонизатор обрабатывает BEMHTML-шаблоны в два этапа:

* компиляция;
* выполнение.


<a name="runpre"></a>
### Компиляция шаблонов

Шаблонизатор компилирует шаблоны по-разному в зависимости от настроек среды исполнения и синтаксиса шаблонов.


<a name="runclassic"></a>
#### Сокращенный синтаксис

Вне зависимости от настроек среды исполнения производятся следующие действия:

* все BEMHTML-шаблоны, участвующие в сборке, собираются в файл бандла;
* шаблоны из бандла преобразуются в XJST-синтаксис.


<a name="runjs"></a>
#### JavaScript-синтаксис

Вне зависимости от настроек среды исполнения производятся следующие действия:

* все BEMHTML-шаблоны, участвующие в сборке, собираются в файл бандла.

**В продакшн-среде исполнения** и для сокращенного, и для JavaScript-синтаксиса выполняются XJST-преобразования, в результате которых генерируется оптимизированный JavaScript-код шаблонов.


<a name="runmain"></a>
### Выполнение шаблонов

Ход выполнения JavaScript-кода, полученного на этапе компиляции шаблонов, одинаков для всех синтаксисов и настроек среды исполнения:

* шаблонизатор принимает на вход БЭМ-дерево в формате [BEMJSON](https://ru.bem.info/technology/bemjson/);
* последовательно обходит узлы входного БЭМ-дерева;
  * в процессе обхода входного BEMJSON-дерева строится структура данных — [контекст](https://ru.bem.info/libs/bem-core/current/bemhtml/reference/#context);
* выполняется цикл генерации выходного HTML-элемента для каждой БЭМ-сущности;
  * рекурсивно выполняется цикл генерации выходных HTML-элементов для вложенных БЭМ-сущностей;
  * поэлементно выполняется запись в буфер фрагментов HTML-результата.


<a name="table"></a>
### Таблица соответствия стандартных операций шаблонизатора в разных синтаксисах


| Операция | Cокращенный синтаксис | JS-синтаксис |
| ------------- |-------------|------------- |-------------|------------- |-------------|
| Совпадение с БЭМ-сущностью | `block b-my-block : тело` | `block('b-my-block')(тело)` |
| Совпадение со стандартной модой  | `tag : 'a'`  | `tag()('a')` |
| Совпадение с нестандартной модой   |  `custom-mode : тело` | `mode('custom-mode')(тело)`  |
| Совпадение с произвольным условием | `block link, this.ctx.url, tag: 'a'` | `block('link').match(function() { return this.ctx.url; }).tag()('a')`  |



<a name="steps"></a>
### Алгоритм преобразования шаблонов из сокращенного в JS-синтаксис
Шаблоны, реализованные в сокращенном синтаксисе, могут приведены к JS-синтаксису с помощью ряда элементарных преобразований.


<a name="steps-table"></a>
#### Таблица пошагового преобразования шаблонов
Кратко алгоритм преобразования шаблонов может быть изложен в виде следующей таблицы:

| Номер шага | Этап | Описание | Паттерн преобразования |
| ------------- |-------------|------------- |-------------|------------- |-------------|
|  1  | Преобразование БЭМ-ориентированных подпредикатов | Взять в кавычки имена БЭМ-сущностей | `b1` → `'b1'` |
|  2 |  | Заменить сокращения для БЭМ-сущностей на хелперы | `block 'b1'` → `block('b1')` |
|  3 |  | Заменить все запятые, разделяющие подпредикаты, на точки | `,`  → `.` |
|  4 | Преобразование произвольных подпредикатов | Обернуть произвольные подпредикаты в хелпер `match` | `произвольный-подпредикат` → `match(произвольный-подпредикат)` |
|  5 | Преобразование подпредикатов для мод | Заменить названия стандартных мод на хелперы | `tag` → `tag()` |
|  6 |  | Обернуть оставшиеся подпредикаты в хелпер `mode` и взять в кавычки | `some-mode` → `mode('some-mode')` |
|  7 | Преобразование тела шаблона и вложенных конструкций | Заменить двоеточие перед телом шаблонов на открывающую скобку и добавить после тела закрывающую | ` : ...`  →  `(...)` |
|  8 |  | Добавить запятые между вложенными подшаблонами | `block('b1'){ tag()('a') elem('e1').tag('b') }` → `block('b1'){ tag()('a'), elem('e1').tag('b') }` |
|  9 |  | Заменить фигурные скобки, указывающие вложенность, обычными скобками | `block('b1'){ tag()('a'), elem('e1').tag('b') }` → `block('b1')(tag()('a'), elem('e1').tag('b'))` |


<a name="steps-examples"></a>
#### Примеры преобразования шаблонов

**Шаблон 1.** Задает для блока `logo` тэг `img`.

Сокращенный синтаксис:

```
block logo {
  tag: 'img'
}
```


JS-синтаксис:

```js
block('logo').tag()('img')
```



**Шаблон 2.** Задает для блока `logo` тэг `img` и соответствующий набор атрибутов.

Сокращенный синтаксис:

```
block logo {
  tag: 'img'
  attrs: ({alt: 'logo', href: 'http://...'})
}
```


JS-синтаксис:

```js
block('logo')(
  tag()('img'),
  attrs()({alt: 'logo', href: 'http://...'})
)
```



**Шаблон 3.** Задает для блока `b-page` тэг `html` и запрещает генерацию класса из имени БЭМ-сущности.

Сокращенный синтаксис:

```
block b-page {
  tag: 'html'
  bem: false
}
```

JS-синтаксис:

```js
block('b-page')(
  tag()('html'),
  bem()(false)
)
```



**Шаблон 4.** Для элементов блока `b-text` устанавливает тэг в соответствие с именем элемента, определенным во входном BEMJSON. Если во входных данных для элемента задано поле `id`, присваивает значение поля атрибуту `id`.

Сокращенный синтаксис:

```
block b-text {

    this.elem, tag: this.ctx.elem

    this.elem, this.ctx.id, attrs: { id: this.ctx.id  }

}
```


JS-синтаксис:

```js
block('b-text')(

    elemMatch(function() { return this.elem; }).tag()(function() { return this.ctx.elem; }),

    elemMatch(function() { return this.elem; }).match(function() { return this.ctx.id; }).attrs()(function() { return { id: this.ctx.id  }; })

)
```


**Шаблон 5.** Для блока `b-bla` по умолчанию задает тэг `span`. Если во входных данных задан модификатор блока `o-mode` в значении `v2`, меняет тэг на `a`. Затем к блоку примешивается модификатор элемента `m2` в  значении `v2` и указывается, что блок содержит JavaScript.

Сокращенный синтаксис:

```
block b-bla {
  tag:'span'
  mod 0-mode v2, tag:'a'
  mix: [ { elemMods: { m2: 'v2' }} ]
  js: true
}
```



JS-синтаксис:

```js
block('b-bla')(
  tag()('span'),
  mod('0-mode', 'v2').tag()('a'),
  mix()([{ mods: { m2: 'v2' } }]),
  js()(true)
)
```


**Шаблон 6.** Оборачивает блок `b-inner` в блок `b-wrapper`. Для этого в моде `default` фрагмент входного BEMJSON подменяется блоком `b-wrapper`, содержащим изначальный фрагмент входных данных.

Сокращенный синтаксис:

```
block b-inner, default: applyCtx({ block: 'b-wrapper', content: this.ctx })
```


JS-синтаксис:

```js
block('b-inner').def()(function() {
    return applyCtx({ block: 'b-wrapper', content: this.ctx });
});
```


**Шаблон 7.** Для элемента `e1` блока `b-bla` по умолчанию задает тэг `span`. Если во входных данных определено поле `url`, меняет тэг на `a` и задает содержимое поля в качестве значения атрибута `href`. При совпадении с нестандартной модой `reset` значение атрибута `href` устанавливается равным `undefined`.

Сокращенный синтаксис:

```
block b-link, elem e1 {
  tag: 'span'
  this.ctx.url {
     tag: 'a'
     attrs: { href: this.ctx.url }
     reset {
         attrs: { href: undefined }
      }
   }
}
```


JS-синтаксис:

```js
block('b-link').elem('e1') (
  tag()('span'),
  match(function() { return this.ctx.url; })(
     tag()('a'),
     attrs()(function() { return { href: this.ctx.url }; }),
     mode('reset')(
         attrs()({ href: undefined })
      )
   )
)
```

