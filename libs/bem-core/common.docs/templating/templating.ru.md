# Шаблонизация данных в bem-core
<a name="intro"></a>

## Введение

**Данный документ** представляет собой справочное руководство по шаблонизации данных в `bem-core`.

В документе описаны:

* основные особенности BEMHTML и BEMTREE, отличающие их от других шаблонизаторов;
* синтаксис шаблонов BEMHTML и BEMTREE;
* порядок обработки входных данных и генерации HTML.

**Целевая аудитория документа** — веб-разработчики и HTML-верстальщики, использующие
[БЭМ-методологию](https://ru.bem.info/method/).

Предполагается, что читатель знаком с:

* HTML
* JavaScript
* CSS
* БЭМ

**В документе не описаны** специфические для BEMTREE и BEMHTML моды и поля контекста, настройки сборки, поставщики данных.


<a name="main"></a>
## Общие сведения

Под **шаблонизацией** в bem-core понимается процесс генерации HTML из некоторых входных данных.

В `bem-core` реализован механизм двухэтапной шаблонизации данных. На первом этапе нормализованные данные, получаемые от бэкенда, преобразуются к view-ориентированному представлению.  Эту функцию выполняет шаблонизатор [BEMTREE](https://ru.bem.info/technology/bemtree/).

BEMTREE формирует **БЭМ-дерево** в формате BEMJSON. БЭМ-дерево описывает:

* структуру страницы – порядок и вложенность блоков;
* названия БЭМ-сущностей – имена блоков, элементов, модификаторов блока или элемента;
* состояния БЭМ-сущностей – наличие логических модификаторов, значения модификаторов;
* произвольные поля – вспомогательные данные (хеш-ключи, адреса публичных API, и т.п.).

На втором этапе ранее сформированный BEMJSON поэлементно преобразуется в HTML. Эту функцию выполняет шаблонизатор [BEMHTML](https://ru.bem.info/technology/bemhtml/current/reference/).

Для каждой БЭМ-сущности создаются HTML-тэги, классы и атрибуты, в соответствии с  BEMHTML-шаблонами для этой сущности.

Такой подход к шаблонизации обеспечивает максимальную гибкость:
* BEMHTML-шаблоны не содержат сведений о бэкенде. Это позволяет использовать блоки с BEMHTML-шаблонами в разных проектах вне зависимости от конкретной схемы работы с данными;
*  BEMHTML-шаблоны не содержат сведений о способе представления БЭМ-сущностей в верстке.



<a name="bemx_arch"></a>
## Архитектура шаблонизаторов BEMHTML и BEMTREE

Для обработки BEMTREE- и BEMHTML-шаблонов используется модуль [bem-xjst](https://ru.bem.info/tools/templating-engines/bemxjst/).
BEM-XJST является надмножеством [языка шаблонов XJST](https://github.com/veged/xjst), который, в свою очередь, является надмножеством JavaScript.

BEM-XJST — это набор БЭМ-ориентированных хелперов, расширяющий
стандартный XJST-синтаксис. В нем определены:

  * хелперы для записи подпредикатов, относящихся к предметной области БЭМ;
  * хелперы для определения подпредиката по моде;
  * хелперы для применения XJST-конструкций `apply` и `applyNext` по произвольной моде;
  * конструкцию [applyCtx](#applyctx).

BEM-XJST реализует наиболее общую схему обработки шаблонов. Логика, специфическая для каждого из шаблонизаторов в отдельности, реализована на уровне их **базовых шаблонов**.

Базовый шаблон – это реализация блока `i-bem` в технологии
 соответствующего шаблонизатора:

* для BEMTREE — [i-bem.bemtree](https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/i-bem.bemtree);
* для BEMHTML — [i-bem.bemhtml](https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/i-bem.bemhtml).

Базовый шаблон определяет:
* набор и порядок выполнения доступных для технологии стандартных [мод](#moda);
* [поля контекста](#context_field);

Можно выделить четыре уровня абстракции, на каждом из которых реализуется часть совокупной логики шаблонизатора:

1. XJST
2. BEM-XJST
3. Базовый шаблон
4. Пользовательский шаблон

Каждый последующий уровень использует  логику, реализованную на предыдущем и дополняет (переопределяет) ее:

* XJST предоставляет базовые конструкции для:
	* проверки истинности подпредикатов (`match`);
	* выполнения тела шаблона в модифицированном контексте (`local` и `apply`).
* BEM-XJST реализует:
	* логику, относящуюся к предметной области БЭМ – хелперы для записи подпредикатов для блоков, элементов, модификаторов;
	* логику для работы с фрагментом входного БЭМ-дерева (поле контекста `this.ctx`) и конструкцию `applyCtx`, предназначенную для его модификации;
	* возможность вызывать `apply`  по моде;
	* общую схему обработки шаблонов.
* Базовый шаблон реализует логику, специфическую для конкретной технологии:
	* набор стандартных мод;
	* поля контекста.

* Пользовательский шаблон или шаблон блока реализует логику, определяющую функциональность конкретного блока или элемента.

![levels](https://raw.githubusercontent.com/Murdalay/bem-core/feature_doc/common.docs/templating/template-levels.png)


<a name="bemx_intro"></a>
### Знакомство с BEM-XJST-шаблонизаторами

Как следствие использования описанной выше архитектуры, синтаксис BEMHTML и BEMTREE почти идентичен. Вся разница между ними заключается в:
* количестве доступных стандартных мод;
* нескольких полях контекста, специфических для каждого из шаблонизаторов.


Общие для BEMHTML и BEMTREE синтаксические конструкции и поля контекста объединены понятием **BEM-XJST-синтаксис**.

Шаблонизаторы, поддерживающие синтаксические конструкции и поля контекста, соответствующие BEM-XJST-синтаксису, называются **BEM-XJST-шаблонизаторами**.



<a name="bemx_basic"></a>
## Особенности BEM-XJST-шаблонизаторов

<a name="bem_area"></a>
### Привязка к БЭМ-предметной области

Шаблонизаторы BEMHTML и BEMTREE входят в связку технологических решений, обеспечивающих создание веб-интерфейсов в рамках
[БЭМ-методологии](https://ru.bem.info/method/).

Входные данные шаблонизатора — БЭМ-дерево в формате [BEMJSON](https://ru.bem.info/technology/bemjson/current/bemjson/), описывающее веб-страницу.
Языки шаблонов BEMHTML и BEMTREE предлагают специальные конструкции для обработки блоков, элементов и модификаторов.


<a name="decl_templatе"></a>

### Декларативные шаблоны

Ниже рассматриваются особенности декларативного подхода к созданию шаблонов на примере шаблонизатора BEMHTML.

Все эти особенности относятся и к шаблонизатору BEMTREE с той оговоркой, что результатом выполнения BEMTREE-шаблонов будет BEMJSON вместо HTML.


<a name="imperativ"></a>

#### Императивный подход

Традиционные шаблонизаторы предлагают **императивный подход** к написанию шаблонов: HTML формируется в процессе
последовательного чтения и выполнения шаблона.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>Результат</th>
</tr>
<tr>
    <td>
        <pre><code>
{
  items: [
    { text: '1' },
    { text: '2' }
  ]
}
        </code></pre>
    </td>

    <td>
        <pre><code>
&lt;ul class="menu"&gt;
    [% foreach item in items %]
        &lt;li class="menu&#95;&#95;item"&gt;
            [% item.text %]
        &lt;/li&gt;
    [% end %]
&lt;/ul&gt;
        </code></pre>
    </td>
    <td>
        <pre><code>
&lt;ul class="menu"&gt;
    &lt;li class="menu&#95;&#95;item">1&lt;/li&gt;
    &lt;li class="menu&#95;&#95;item">2&lt;/li&gt;
&lt;/ul&gt;
        </code></pre>
    </td>

</tr>
</table>

В таком шаблоне неизбежна избыточность, вызванная синтаксическими требованиями HTML: *вывести открывающий
тег — сгенерировать содержимое — вывести закрывающий тег*. Еще выше избыточность в таблицах, списках и т.п.


<a name="declarativ"></a>

#### Декларативный подход

**Декларативный подход** позволяет формулировать шаблоны как набор простых утверждений вида: *тип входных данных (БЭМ-сущность) — HTML-представление (тег, атрибут и т.п.)*.

<table>
    <tr>
        <th>Входные данные</th>
        <th>Шаблон</th>
        <th>Результат</th>
    </tr>
    <tr>
        <td>
        <pre><code>
{
    block: 'menu',
    content: [
        { elem: 'item', content: '1' },
        { elem: 'item', content: '2' }
    ]
}
        </code></pre>
        </td>
        <td>
        <pre><code>
block('menu')(
    tag()('ul'),
    elemMatch('item').tag()('li')
)
        </code></pre>
        </td>
        <td>
        <pre><code>
&lt;ul class="menu"&gt;
    &lt;li class="menu&#95;&#95;item"&gt;1&lt;/li&gt;
    &lt;li class="menu&#95;&#95;item"&gt;2&lt;/li&gt;
&lt;/ul&gt;
        </code></pre>
        </td>
    </tr>
</table>


Декларативность шаблонов достигается за счет того, что в BEMHTML процедура генерации HTML-элемента стандартизирована и выполняется шаблонизатором. Этот же подход к выполнению преобразований данных используется в XSLT и AWK.


<a name="language"></a>

### Язык описания и исполнения шаблонов — JavaScript

Шаблонизаторы BEMHTML и BEMTREE представляют собой специализированный язык (DSL), **расширяющий** JavaScript.

В шаблонах могут использоваться **любые** JavaScript-конструкции.

Перед выполнением шаблоны компилируется в оптимизированный JavaScript, который принимает BEMJSON и возвращает HTML для BEMHTML и BEMJSON для BEMTREE.

Такой шаблон может выполняться как на стороне сервера, так и на стороне клиента.


<a name="restrictions"></a>

### Ограничения на уровне соглашений

Разработчики шаблонизатора стремились сделать его максимально гибким инструментом, поэтому в BEMHTML или BEMTREE не предусмотрено
технологических ограничений на операции, выполняемые в шаблонах. Фактически, в коде шаблона возможно всё, что возможно в JavaScript.

Все ограничения, обеспечивающие корректность и эффективность выполнения задач шаблонизатора, реализуются на уровне соглашений по написанию шаблонов. Такие соглашения приводятся в данном документе в качестве рекомендаций. Разработчик
имеет техническую возможность не следовать соглашениям, но в этом случае следует взвесить преимущества и недостатки своего решения.


<a name="basic"></a>

## Основные понятия

<a name="template_ingeneral"></a>
### Шаблон

Единицей программы на BEMHTML и BEMTREE является **шаблон**. Шаблон связывает входную БЭМ-сущность (заданную именем сущности, элемента, именем и значением модификатора) и соответствующий этой сущности выходной HTML-элемент или фрагмент BEMJSON.

Шаблон состоит из:

* **предиката** — набора условий, при выполнении которых применяется шаблон. Типичный предикат описывает свойства входной БЭМ-сущности;
* и **тела** — инструкций по генерации результата.

**См. также**:

* [BEM-XJST-синтаксис шаблонов](#unity)


<a name="inputdata"></a>

### Входные данные: BEMJSON

Поскольку BEM-XJST-шаблонизаторы основаны на JavaScript, стандартным форматом представления БЭМ-дерева выбрана структура данных (объект) JavaScript, с набором дополнительных соглашений о представлении БЭМ-сущностей — BEMJSON.

В рамках шаблона поле `this.ctx` содержит фрагмент входных данных, относящийся к текущему элементу BEMJSON-дерева и его потомкам.

Манипуляции с БЭМ-деревом могут производиться несколькими способами:
* путем присвоения значения полю `this.ctx` или его дочерним полям (`this.ctx.foo = 'bar'`). При этом в качестве значения может, например, выступать результат вычисления функции, возвращаемый в ходе выполнения шаблона;
* путем присвоения полю `this.ctx` или его дочерним полям в качестве значения литерала, описывающего фрагмент БЭМ-дерева в формате BEMJSON. Например `this.ctx = { block: 'foo', content: { elem: 'bar' }}`;
* с помощью **специальных конструкций BEM-XJST**, предназначенных для модификации контекста (`local`, `apply` и `applyNext`) и подмены входного БЭМ-дерева (`applyCtx`).

**См. также**:

* [Поля контекста](#context_field)
* [Специальные конструкции BEM-XJST](#xjst)


<a name="moda"></a>

### Мода

В процессе работы шаблонизатор последовательно обходит узлы входного БЭМ-дерева. Для каждого узла — БЭМ-сущности — выполняется цикл генерации результата:
* HTML-элемента для технологии BEMHTML;
* фрагмента BEMJSON для технологии BEMTREE.


Для вложенных сущностей цикл генерации результата выполняется рекурсивно. Таким образом, результат формируется поэлементно в процессе обхода входного БЭМ-дерева.

Цикл генерации каждого элемента последовательно проходит ряд фаз, называемых **модами**.

Например, в технологии BEMHTML каждая мода отвечает за определенный фрагмент генерируемого HTML-элемента — тег, атрибуты, класс и т.п.

В каждой моде вызывается процедура выбора и выполнения подходящего шаблона.

Особый статус имеет **мода default**, которая отвечает за генерацию результата вцелом для текущей БЭМ-сущности. В рамках этой
моды задан набор и порядок прохождения остальных мод,  а также определена
процедура сборки финального представления HTML-элемента или BEMJSON из фрагментов, сгенерированных в остальных модах. Написание
шаблона, который переопределяет поведение в данной моде, позволяет полностью контролировать генерацию элемента непосредственно из шаблона, не пользуясь стандартными модами, позволяющими генерировать выходной элемент по частям.

**См. также**:

* [Стандартные моды BEMHTML](https://ru.bem.info/technology/bemhtml/current/reference/#standardmoda)
* [Стандартные моды BEMTREE](https://ru.bem.info/technology/bemtree/current/bemtree/#standardmoda)


<a name="context"></a>

### Контекст

В процессе обхода входного BEMJSON-дерева шаблонизатор строит **контекст** — структуру данных, которая доступна в момент применения шаблонов. Контекст соответствует текущему элементу (узлу) входного БЭМ-дерева и включает:

* нормализованные сведения о текущей БЭМ-сущности;
* фрагмент входных данных без модификаций (текущий элемент BEMJSON-дерева и его потомки);
* строковый буфер, в который записывается HTML-результат для BEMHTML или BEMJSON для BEMTREE;
* служебные поля, содержащие сведения о текущем состоянии (мода, позиция во входном БЭМ-дереве и т.п.);
* вспомогательные функции.

БЭМ-сущность, описываемая текущим контекстом, называется **контекстной сущностью**.

**См. также**:

* [Поля контекста](#context_field)
* [Достраивание БЭМ-сущностей по контексту](#extensionbem)



<a name="unity"></a>

## BEM-XJST-синтаксис шаблонов

В данном разделе описаны все синтаксические конструкции языков BEMHTML и BEMTREE.

<a name="template"></a>

### Шаблон

Шаблон состоит из двух выражений — **предиката** и **тела**.
Каждый **предикат** представляет собой список из одного или более **подпредикатов** (условий).

Предикат шаблона истинен тогда и только тогда, когда истинны все
подпредикаты. Порядок записи подпредикатов не имеет значения, *порядок проверки подпредикатов не гарантируется*.

Для описания шаблона используется ключевое слово `match`.  Ключевое слово `match` — это метод-хелпер, принимающий аргументом
перечень подпредикатов. Метод возвращает функцию, принимающую аргументом тело шаблона.

```js
match(подпредикат1, подпредикат2, подпредикат3)(тело);
```

Например:

```js
match(this.block === 'link', this._mode === 'tag', this.ctx.url)('a');
```

Тот же набор подпредикатов может быть записан цепочкой:

```js
match(this.block === 'link').match(this._mode === 'tag').match(this.ctx.url)('a');
```


Логически программа на BEMHTML и BEMTREE представляет собой одноранговый (плоский) **список шаблонов**. Однако если несколько
шаблонов имеют **общие подпредикаты**, они могут быть записаны в виде вложенной структуры для минимизации повторов в коде.

Вложенные подпредикаты помещаются в тело общего подпредиката и отделяются друг от друга запятыми. Уровень вложенности подпредикатов не ограничен.

```js
match(подпредикат1)(
  match(подпредикат2)(тело1),
  match(подпредикат3)(тело2)
)
```

Данная запись эквивалентна следующей:

```
match(подпредикат 1).match(подпредикат 2)(тело1)
match(подпредикат 1).match(подпредикат 3)(тело2)
```


**NB** Если для данного контекста определено более одного шаблона, то
больший приоритет имеет **последний** в порядке перечисления в файле шаблона.
Более специфические шаблоны должны быть ниже в тексте, чем более общие.


**См. также**:

* [Проверка подпредикатов в определенном порядке](https://ru.bem.info/technology/bemhtml/current/reference/#check_predicate)

<a name="podpredicate"></a>

### Подпредикаты

Предикат шаблона представляет собой набор условий, описывающих момент применения шаблона. Подпредикат шаблона соответствует элементарному условию.

В BEM-XJST предусмотрены следующие типы условий:

* Совпадение с входным БЭМ-деревом.
* Мода.
* Произвольное условие


#### Совпадение с входным БЭМ-деревом
Условия совпадения с входным БЭМ-деревом позволяют описывать применимость шаблона в терминах БЭМ-сущностей: имен блоков и элементов, имен и значений модификаторов.

Для сокращенной записи подпредикатов используются ключевые слова, относящиеся к БЭМ-предметной области.
В частности, они избавляют от необходимости использовать ключевое слово `match` в БЭМ-ориентированных подпредикатах.


Следующие предикаты тождественны:

```js
match(this.block === 'foo').match(this.elem === 'bar')
```

```js
block('foo').elem('bar')
```

Используются следующий набор ключевых слов:

<table>
<tr>
    <th>Ключевое слово</th>
    <th>Аргументы</th>
    <th>Тип значения</th>
    <th>Пример</th>
</tr>
<tr>
    <td><code>block</code></td>
    <td>имя блока</td>
    <td>идентификатор <code>[a-zA-Z0-9-]+ </code> или произвольное js-выражение</td>
    <td><pre><code>block('b-menu'), block('b' + '-menu')</code></pre></td>
</tr>
<tr>
    <td><code>elem</code></td>
    <td>имя элемента</td>
    <td>идентификатор <code>[a-zA-Z0-9-]+</code> или произвольное js-выражение</td>
    <td><pre><code>block('b-menu').elem('item')</code></pre></td>
</tr>
<tr>
    <td><code>mod</code></td>
    <td>имя и значение модификатора блока</td>
    <td>идентификатор <code>[a-zA-Z0-9-]+ </code>или произвольное js-выражение</td>
    <td><pre><code>block ('b-head-logo').mod('size', 'big')</code></pre></td>
</tr>
<tr>
   <td><code>elemMod</code></td>
   <td>имя и значение модификатора элемента</td>
   <td>идентификатор <code>[a-zA-Z0-9-]+ </code>или произвольное js-выражение</td>
   <td><pre><code>block('b-head-logo').elem('text').elemMod('size', 'big')</code></pre></td>
</tr>
</table>

Идентификаторы блоков, элементов, модификаторов и их значений представляют собой строку, состоящую из латинских символов и дефиса. Вместо идентификатора может быть
указано любое JS-выражение, которое будет приведено к строке. Например, запись `block('b-head-logo')` тождественна записи `block('b-' + 'head' + '-logo')`.

***
**NB** Важно не путать в предикатах модификаторы блока и модификаторы элемента.

 * `block('input').mod('theme', 'black').elem('hint')` задает элемент `hint`, вложенный в блок `input` с **модификатором блока**
   `theme` в значении `black`.
 * `block('input').elem('hint').elemMod('visibility', 'visible')` задает элемент `hint` с **модификатором элемента** `visibility`
   в значении `visible` вложенный в блок `input`.
 * `block('input').mod('theme', 'black').elem('hint').elemMod('visibility', 'visible')` задает элемент `hint` с **модификатором
   элемента** `visibility` в значении `visible` вложенный в блок `input` с **модификатором блока** `theme` в значении
   `black`.

Для модификаторов блоков и элементов используются разные ключевые слова, чтобы дать возможность комбинировать
в предикатах условия, одновременно включающие упоминания модификаторов блоков и элементов.

***

Чтобы шаблоны выполнялись без компиляции, было добавлено ключевое слово `elemMatch`. Оно используется при записи произвольного подпредиката для элемента:


```js
block('my-block')
    .elemMatch(function() { return this.elem === 'e1' || this.elem === 'e2'  })
        .tag()('span')
```


Дело в том, что в процессе обработки к шаблонам, где нет
подпредикатов, описывающих элементы, автоматически добавляется
подпредикат `!this.elem`. Это позволяет избежать срабатывания шаблонов
для блока на элементах этого же блока.

Как следствие, приведенный выше пример, записанный с конструкцией
`match` вместо `elemMatch`, работать не будет, поскольку в процессе обработки к нему будет добавлен подпредикат  `!this.elem`.


<a name="moda2"></a>

#### Мода

В качестве подпредиката может выступать метод-хелпер для одной из стандартных мод. Это означает, что данный
предикат будет истинным в тот момент обработки, когда выставлена соответствующая мода.

Для проверки стандартных мод используются ключевые слова:
В BEMHTML:
* `def` (мода `default`)
* `tag`
* `bem`
* `mix`
* `cls`
* `js`
* `jsAttr`
* `attrs`
* `content`

В BEMTREE:
* `def` (мода `default`)
* `content`

Хелпер для стандартных мод записывается в виде:

```
ключевое-слово()(тело)
```

Например:

```js
tag()('a')
```
или

```js
js()(true)
```

Для определения подпредиката по нестандартной моде
используется ключевое слово `mode`. Это метод-хелпер, действующий
аналогично конструкции `match`. Метод принимает аргументом строку-идентификатор (`[a-zA-Z0-9-]+`) — название нестандартной моды — и возвращает функцию, аргументом которой служит тело шаблона. Таким образом, запись `mode('my-mode')` эквивалентна записи `match(this._mode === 'my-mode')`.


<a name="random_condition"></a>

#### Произвольное условие

Произвольные условия учитывают совпадения с данными, не попадающими под предметную область БЭМ. В качестве произвольного
условия может выступать любое JavaScript-выражение, которое будет приведено к логическому значению.

***
**NB** Произвольные условия предпочтительно записывать в <a name="xjst-canonical"></a> **канонической форме XJST**:

```
предикатное выражение === значение
```

Где

* `предикатное выражение` — произвольное JavaScript-выражение, приводимое к логическому значению;
* `значение` — произвольное JavaScript-выражение.

При этом количество **различных** предикатных выражений в подпредикатах шаблонов должно быть минимизировано.
Соблюдение этих условий позволит компилятору XJST производить оптимизации над произвольными условиями шаблонов
наряду с оптимизацией стандартизованных условий (БЭМ-сущности и моды).


Для записи произвольного предикатного выражения используется ключевое слово `match`. Например:

```js
match(this.ctx.url)( //произвольное условие. Проверяет наличие поля url во входных данных
        tag()('a'),
        attrs()({ href: this.ctx.url })
    )
```

Произвольный подпредикат `this.ctx.url` будет истинен, в случае, когда полю `url` во входных данных присвоено значение. В этом случае будет выполнено тело шаблона.
***

<a name="body"></a>

### Тело

Тело шаблона представляет собой выражение, результат вычисления которого используется для генерации выходного результата:
* фрагмента HTML для BEMHTML-шаблона;
* фрагмента BEMJSON, в случае с BEMTREE.


В качестве тела шаблона может выступать:

* Отдельное JavaScript-выражение:

```js
match(предикат)(JS-выражение)
```

* Блок JavaScript-кода:

```js
match(предикат)(function() { JS-код })
```

* Литерал объекта (хеш):

```
match(предикат)({name: value})
```


***
**NB** Необходимость оборачивать блок  JavaScript-кода в безымянную функцию продиктована особенностями исполнения шаблонов в среде разработки. Это рекомендуемый способ. Он позволяет избежать возникновения ошибки при обращении к полям контекста, которые могут быть еще не определены на момент выполнения шаблона.

В случае если блок JavaScript-кода представляет из себя простой константный литерал, необходимость в безымянной функции отсутствует.
***


Тело шаблона передается аргументом в функцию, возвращаемую методом `match` и хелперами для БЭМ-сущности или моды.


Синтаксис:

```
стандартная-мода()(тело)

mode('нестандартная-мода')(тело)

БЭМ-сущность('имя-сущности')(тело)

match(произвольный предикат)(тело)
```


***
**NB**  Важно помнить, что тело шаблона передается в функцию, возвращаемую методом-хелпером, а не в сам хелпер.


Неправильно:
```js
block('b1').tag('span')
```

Правильно:

```js
block('b1').tag()('span')
```

***

В рамках тела шаблона можно выполнить следующие действия:

* Вычислить и вернуть значение.
Если в текущей моде ожидается значение определенного типа, значение, возращаемое при вычислении тела шаблона, будет приведено к этому типу и использовано. Если шаблон не возвращает никакого значения, будет использовано значение `undefined`.
* Вывести данные непосредственно в HTML-результат (или в BEMJSON).
  Для этого в теле шаблона следует выполнить запись в буфер результата (`this._buf.push(…)`).
* Производить произвольные операции.

<a name="xjst"></a>

### Специальные конструкции BEM-XJST

Для интерпретации BEMHTML- и BEMTREE-шаблонов используется модуль [bem-xjst](https://ru.bem.info/tools/templating-engines/bemxjst/). BEM-XJST  представляет собой набор БЭМ-ориентированных хелперов, расширяющих предметную область языка [XJST](https://github.com/veged/xjst).

Помимо хелперов для БЭМ-сущностей и названий мод в шаблонах возможно использовать специальные синтаксические
конструкции BEM-XJST. Они предназначены для модификации контекста и явного вызова процедуры выбора и выполнения шаблонов в измененном контексте.


**NB** Обратите внимание, что функциональность и синтаксис
**BEM-XJST-конструкций** (например, конструкции `apply()`) может отличаться от синтаксиса и функциональности аналогичных конструкций языка XJST.


<a name="local"></a>

#### local

Конструкция `local` используется для временного изменения контекста и переменных, а также для последующих
операций с ними. По синтаксису блок кода `local` подобен блокам `while` и `for` в JavaScript.

Блок `local` записывается в виде:

```
local(this)({hash})(function() {
    // code
})
```


Здесь

* `this` — объект, используемый в качестве контекста. Может не указываться, тогда будет использован текущий контекст;
* `hash` — хеш, ключи которого – это поля контекста. В хеше могут использоваться вложенные конструкции вида `ctx.foo`. Переданные в хеше значения переменных будут присвоены полям контекста в момент выполнения блока `local`;
* `code` — JavaScript-код, который выполняется в контексте, где значения переменных соответствуют присвоенным в блоке
  `hash`.

По выходу из блока local все переменные, значения которых изменялись в блоке `hash`, приобретают те значения, которые в них хранились на момент входа в блок.


**NB** Если в блоке `hash` было присвоено значение переменной (полю объекта), которая не была определена на момент входа в блок `local`, по выходу из блока `local` эта переменная (поле) будет существовать и получит значение `undefined`.


Блок `hash` может записываться следующим образом:

```js
local()({ x: 1, 'a.b.c': 2 })(function() {

   // statements body

})
```


<a name="apply"></a>

#### apply

Конструкция `apply` предназначена для явного вызова процедуры выбора и выполнения шаблона, предикат которого истинен
в данном контексте. Конструкция позволяет вызывать шаблоны в модифицированном контексте.

Синтаксис:

```js
apply({assignObj})
```

Где `{assignObj}` — объект, ключи которого становятся полями контекста при входе в блок `applyNext`. Объект может отсутствовать.

Первым аргументом может быть передана строка, которая интерпретируется как название моды.

Например, выражение `apply('content')` эквивалентно выражению `apply({ _mode : 'content' })`.

При вычислении выражения `apply` выполняются следующие шаги:

1. Установка полей контекста, определенных в объекте `{assignObj}`.
2. Вызов процедуры выбора и выполнения шаблона в контексте, полученном в результате шага 1.
3. Восстановление исходных значений полей контекста.

Конструкция `apply({assignObj})` представляет собой сокращенную запись выражения `local({assignObj})(apply())`.

<a name="applynext"></a>

#### applyNext

Конструкция `applyNext` позволяет явно запустить процедуру применения шаблонов в текущем или модифицированном контексте из тела шаблона. Применяются все шаблоны с подходящим предикатом, кроме текущего.

Например, если у шаблона блока существует базовая реализация, при вызове `applyNext` будет возвращен результат ее применения:

```js
block('b1').tag()('span')
block('b1').tag()(function() { return applyNext(); }) // span
```

Синтаксис:

```js
applyNext({assignObj})
```

Где `{assignObj}` — объект, ключи которого становятся полями контекста при входе в блок `applyNext`. Объект может отсутствовать.

Первым аргументом может быть передана строка, которая интерпретируется как название моды.

При вызове `applyNext` выполняются следующие шаги:

  1. Создание в контексте флага, позволяющего избежать бесконечной рекурсии при вызове шаблонов. В качестве флага
     используется случайное число.
  2. Добавление в предикат шаблона проверки на наличие флага.
  3. Установка полей контекста, определенных в объекте `{assignObj}`.
  4. Вызов процедуры выбора и выполнения шаблона `apply`.
  5. Возвращение значения, полученного в результате выполнения шаблона.

Например, шаблон

```js
block('b1')(function() {
    statements
    return applyNext();
})
```

эквивалентен следующему шаблону:

```js
var _randomflag = ~~(Math.random() * 1e9)
block('b1').match(function() { return !this.ctx[_randomflag]; })(
    statements
    local(this.ctx[_randomflag] = true) apply()
)
```

Где `statements` — произвольные JS-выражения, допустимые в теле шаблона.

**См. также**:

* [Наследование](https://ru.bem.info/technology/bemhtml/current/reference/#inheritage)
* [Добавление БЭМ-сущностей для задач верстки](https://ru.bem.info/technology/bemhtml/current/reference/#additionbem)

<a name="applyctx"></a>

#### applyCtx

Конструкция `applyCtx` предназначена для модификации текущего фрагмента БЭМ-дерева `this.ctx` с вызовом процедуры применения шаблонов `apply()`.

Синтаксис:

```js
applyCtx({assignObj}, newctx)
```

Принимаемые аргументы: 

* [`{Object}` `assignObj`] – объект, ключи которого становятся полями контекста при входе в `applyCtx`.
* `{Object}` `newctx` – объект, с новым входным фрагментом БЭМ-дерева. Может содержать ссылки на исходный `this.ctx`. Обязательный аргумент.

При вызове `applyCtx` выполняются следующие шаги:

  1. Выставление [пустой моды](https://ru.bem.info/technology/bemhtml/current/reference/#empty_moda) в качестве текущей.
  2. Вызов процедуры выбора и выполнения шаблона `apply()`.
  3. Возвращение значения, полученного в результате выполнения шаблона.

Выражение `applyCtx(newctx)` представляет собой сокращенную запись для выражения `applyNext(this, { _mode: '', ctx: newctx })`.

***
**NB** При использовании объекта `this.ctx` в качестве аргумента для applyCtx() нужно:

* добавить в контекст флаг, позволяющий избежать бесконечной рекурсии при вызове шаблона;
* добавить в предикат шаблона проверку на наличие флага.

***

**См. также**:

  * [Оборачивание блока в другой блок](https://ru.bem.info/technology/bemhtml/current/reference/#wrappingunit)
  * [Добавление БЭМ-сущностей для задач верстки](https://ru.bem.info/technology/bemhtml/current/reference/#additionbem)

<a name="context_field"></a>

## Поля контекста

В процессе работы шаблонизаторы строят **контекст** — структуру данных, содержащую сведения об обрабатываемом узле BEMJSON и о состоянии процесса обработки. Помимо этого в контексте доступен ряд вспомогательных функций.

В момент выполнения шаблона контекст доступен в виде объекта, обозначаемого ключевым словом `this`. Обращение к контексту возможно как в предикате, так и в теле шаблона.

Автор шаблонов имеет возможность определить любые дополнительные поля в контексте.

Все поля контекста можно разделить на две категории:

  * **Контекстно-зависимые**, значение которых изменяется в зависимости от обрабатываемого узла и фазы процесса обработки.
  * **Контекстно-независимые**, значение которых постоянно.

**См. также**:

  * [Контекст](#context)

<a name="contextdependent"></a>

#### Контекстно-зависимые поля

<table>
<tr>
    <th>Поле</th>
    <th>Тип значения</th>
    <th>Описание</th>
</tr>
<tr>
    <td><code>this.block</code></td>
    <td><code>String</code></td>
    <td>Имя блока (контекстной БЭМ-сущности).</td>
</tr>
<tr>
    <td><code>this.elem</code></td>
    <td><code>String</code></td>
    <td>Имя элемента (контекстной БЭМ-сущности).</td>
</tr>
<tr>
    <td><code>this.mods</code></td>
    <td><code>Object</code></td>
    <td>Модификаторы блока (контекстной БЭМ-сущности), <code>имя_модификатора: значение_модификатора</code>.</td>
</tr>
<tr>
    <td><code>this.elemMods</code></td>
    <td><code>Object</code></td>
    <td>Модификаторы элемента (контекстной БЭМ-сущности), <code>имя_модификатора: значение_модификатора</code>.</td>
</tr>
<tr>
    <td><code>this.ctx</code></td>
    <td><code>BEMJSON</code></td>
    <td>Фрагмент входного BEMJSON-дерева, содержащий обрабатываемый узел и его потомков в неизмененном виде.
    Используется для получения доступа к произвольным полям данных входного BEMJSON.</td>

<tr>
    <td><code>this._mode</code></td>
    <td><code>String</code></td>
    <td>Текущая мода. Если необходимо определить собственные (нестандартные) моды, в соответствующем шаблоне следует
    присваивать этому полю имя моды в момент входа в нее. </td>
</tr>
<tr>
    <td><code>this._buf</code></td>
    <td><code>Array</code></td>
    <td>Буфер BEMJSON-результата. Обычно используется только для записи готовых BEMJSON-фрагментов с использованием метода
    <code>this._buf.push()</code>.</td>
</tr>
<tr>
    <td><code>this.generateId()</code></td>
    <td><code>Number</code></td>
    <td>Возвращает уникальный идентификатор для текущего контекста. Используется, для генерации уникальных идентификаторов для  HTML-элементов, связанных с помощью атрибута <code>id</code>.</td>
</tr>
</table>

***
**NB**
Ключевые слова для проверки БЭМ-сущностей в предикате являются сокращенной записью для проверки значений полей
`block`, `elem` и т.д. в текущем контексте. Например, подпредикат `block('b1')` эквивалентен подпредикату
`match(this.block === 'b1')`.

Аналогично, ключевые слова для проверки моды в предикате являются сокращенной записью для проверки значения
служебного поля `_mode` в текущем контексте. Например, подпредикат `def()` эквивалентен подпредикату
`match(this._mode === 'default')`.
***



<a name="context_independent"></a>

### Контекстно-независимые поля

Все контекстно-независимые поля сгруппированы в объекте `this` и представляют собой вспомогательные функции,
используемые при работе шаблонизатора. Автор шаблонов также может пользоваться этими функциями как в теле шаблонов,
так и в предикатах.

<table>
<tr>
    <th>Поле</th>
    <th>Тип значения</th>
    <th>Описание</th>
</tr>
<tr>
    <td><code>this.isArray(Object)</code></td>
    <td><code>Boolean</code></td>
    <td>Проверяет, является ли данный объект массивом.</td>
</tr>
<tr>
    <td><code>this.isSimple(Object)</code></td>
    <td><code>Boolean</code></td>
    <td>Проверяет, является ли данный объект примитивным JavaScript типом.</td>
</tr>
<tr>
    <td><code>this.extend(Object, Object)</code></td>
    <td><code>Object</code></td>
    <td>Возвращает хэш, объединяющий содержимое двух хэшей, переданных в качестве аргументов. Если хэши содержат
    совпадающие ключи, в результат записывается значение из хэша, переданного в качестве второго аргумента.</td>
</tr>
<tr>
    <td><code>this.xmlEscape(String)</code></td>
    <td><code>String</code></td>
    <td>Возвращает переданную строку с заэкранированными управляющими символами XML <code>[&<>]</code>.</td>
</tr>
<tr>
    <td><code>this.attrEscape(String)</code></td>
    <td><code>String</code></td>
    <td>Экранирует значение управляющих символов для значений XML- и HTML-атрибутов  (<code>"[&<>]</code>).</td>
</tr>
</table>

<a name="custom_static_methods"></a>

#### Добавление пользовательских методов к контекстно-независимым полям

Набор вспомогательных функций, доступный в контекстно-независимых полях, определяется базовым блоком шаблонизатора. Это позволяет использовать различный набор функций для BEMTREE и BEMHTML.

Технически, вспомогательные функции являются статическими методами псевдоклассового конструктора `BEMContext`, реализованного в базовых блоках (`i-bem.bemhtml` и `i-bem.bemtree`).

Доступный набор функций может быть дополнен пользователем. Для этого нужно расширить прототип `BEMContext` новым статическим методом. После этого добавленный метод будет доступен в шаблонах в контексте блока:

```js
oninit(function(exports, context) {
    context.BEMContext.prototype.newMethod = function() {
        /* ... */
    }
});

block('b1').content()(function() {
    this.newMethod();
});
```


**NB** Статические методы функций-конструкторов по умолчанию вызываются в контексте самой функции-конструктора. Так, внутри метода `newMethod` ссылка `this` при вызове будет указывать на конструктор `BEMContext`.


<a name="extensionbem"></a>

#### Достраивание БЭМ-сущностей по контексту

В BEMJSON принято записывать БЭМ-сущности в свернутом виде. Например, если в блок `menu` вложен элемент `item`,
в объекте, описывающем пункт меню, не указывается имя содержащего его блока меню:

```js
{
  block: 'menu',
  content: {
    elem: 'item'
  }
}
```

Информация о том, что элемент `item` принадлежит блоку `menu`, достраивается по контексту (на основании вложенности)
в процессе работы шаблонизатора. В момент, когда контекстной сущностью является блок `menu`, в полях контекста будут
выставлены следующие значения:

```js
this.block: 'menu'
this.elem: undefined
this.ctx.block: 'menu'
this.ctx.elem: undefined
```

В момент входа во вложенный элемент `item` в поле `this.block` достраивается значение `menu`. В то же время в поле
`this.ctx.block` находится значение `undefined`, так как во входном BEMJSON это поле в элементе `item` не определено:

```js
this.block: 'menu'
this.elem: 'item'
this.ctx.block: undefined
this.ctx.elem: 'item'
```

Достраивание выполняется также для элементов, примешанных внутри блоков. Например, в приведенном БЭМ-дереве:

```js
{ block: 'b1', mix: { elem: 'e1' } }
```

В примешанном элементе будет достроено имя блока:

```js
{ block: 'b1', mix: { block: 'b1', elem: 'e1' } }
```

Достраивание БЭМ-сущностей необходимо для корректного срабатывания предикатов на элементы блоков вида
`block('menu').elem('item')`, так как в таких предикатах проверяются значения полей контекста `this.block` и `this.elem`.

**NB** Чтобы избежать срабатывания предикатов вида `block('menu')` внутри вложенных в блок элементов, на этапе компиляции
шаблонов к таким предикатам в необходимых случаях автоматически добавляется подпредикат `!this.elem`. Автоматическое
добавление может не сработать, если предикат шаблона содержит подпредикат с произвольным условием, записанный
не в [канонической форме XJST](#xjst-canonical).


<a name="polymorph"></a>
## Сборка и подключение бандла технологий BEMTREE и BEMHTML

В соответствии с [БЭМ методологией](https://ru.bem.info/method/) реализации шаблонов BEMHTML и BEMTREE размещаются в [файловой системе](https://ru.bem.info/method/filesystem/) как набор файлов с суффиксами `.bemhtml` и `.bemtree` соответственно.

Файлы шаблонов размещаются в каталогах блоков, использующих шаблонизацию, а также в каталогах элементов.

В терминах БЭМ каждый блок или элемент, использующий шаблонизацию, содержит файлы шаблонов, реализованные в **технологиях** BEMHTML и (или) BEMTREE.

Чтобы использовать BEMHTML- или BEMTREE-шаблоны блоков и элементов нужно:
* произвести **сборку** файлов технологий из блоков в файл **бандла технологии** (иначе называемый рантайм бандл);
* подключить файл бандла к проекту.

Средства и инструменты, с помощью которых осуществляется сборка, называются **технологией сборки**.



<a name="make"></a>
### Сборка

В `bem-core` используется технология сборки с помощью пакета [bem-tools](https://ru.bem.info/tools/bem/bem-tools/).

Например, в [project-stub](https://github.com/bem/project-stub) с поддержкой `bem-core`, сборка производится в ходе работы сервера, вызываемого командой `bem server` или командой `bem make`.

При сборке командой `bem server` файлы с суффиксом `.bemhtml`  автоматически собираются из блоков, со всех используемых по умолчанию [уровней переопределения](https://ru.bem.info/tools/bem/bem-tools/levels/). Подключение также производится автоматически.

Для файлов с суффиксом `.bemtree` автоматическая сборка командой `bem server`  не производится. О том, как настроить их сборку в `project-stub`, читайте в разделе [Как настроить сборку BEMTREE в project-stub](#buthow).

В `project-stub` бандлы,  собранные из файлов технологий блоков, по умолчанию сохраняются в каталоге `index` на уровне переопределения  `desktop.bundles`:

* для BEMHTML-шаблонов — `index.bemhtml.js`;
* для BEMTREE-шаблонов — `index.bemtree.js`.

Помимо сборки и минимизации кода, **модуль технологии** `bem-tools`, осуществляющий сборку, добавляет в файл бандла полиморфную обвязку, которая:

1. Позволяет подключить бандл как [YModules](https://ru.bem.info/tools/bem/modules/);
2. Позволяет подключить бандл как CommonJS-модуль;
3. Формирует из бандла глобальный объект, в случае если ни один из предыдущих способов не был использован (по умолчанию только для BEMHTML).


<a name="buthow"></a>
### Как настроить сборку BEMTREE в project-stub
Напомним, что в `project-stub` с поддержкой `bem-core` в качестве системы сборки используется пакет [bem-tools](https://ru.bem.info/tools/bem/bem-tools/).

Чтобы включить в сборку bemtree-файлы блоков нужно:
* добавить в файл `.bem/make.js` имя технологии  `'bemtree'` к списку технологий, возвращаемых методом `getTechs`;
* добавить к декларации сборки (например `index.bemjson.js`) в папке с собираемым бандлом, имена блоков, из которых нужно собирать bemtree-файлы . В качестве альтернативы, для этих целей можно использовать deps.js-файлы внутри блоков, участвующих в сборке.  При этом базовой декларацией может выступать файл технологии bemdecl.js вместо bemjson.js

Для осуществления сборки используется команда `bem make`. Например бандл `index.bemtree.js` в каталоге `index` на уровне переопределения `desktop.bundles может быть собран следующей командой:

```
bem make desktop.bundles/index/index.bemtree
```

После этого собранный бандл может быть подключен к проекту любым удобным способом из числа описанных выше.

**NB** Каталог `.bem` находится в корне проекта и содержит файлы с настройками сборки и кеш.


<a name="require"></a>
### Подключение

<a name="ymodule"></a>
#### BEMHTML как YModules

Бандл технологии BEMHTML может быть подключены с помощью модульной системы YModules. Чтобы подключить модуль, нужно воспользоваться асинхронным методом `modules.require`:

```js
modules.require(['BEMHTML'],  function(BEMHTML) {
	// user code
  });
```

Первым параметром методу передается массив строк – имен подключаемых
модулей. Вторым параметром – callback-функция, которой передаются
объекты соответствующих модулей после разрешения зависимостей.

**NB** Подключаемый модуль должен быть собран в общий рантайм бандл с подключающим.


<a name="commonjs"></a>
#### BEMHTML как CommonJS

Чтобы подключить бандл технологий BEMHTML как CommonJS-модуль нужно воспользоваться стандартным методом NodeJS `require`.
При этом требуется явно указать путь до бандла:

  ```js
var    BEMHTML = require('./desktop.bundles/index/index.bemhtml').BEMHTML;
  ```

В примере выше путь приведен относительно модуля, расположенного в корневом каталоге проекта.


<a name="globalobj"></a>
#### BEMHTML в виде глобального объекта

Глобальный объект BEMHTML будет доступен в случае, если бандл
`.bemhtml.js` не был подключен с помощью YModules или как CommonJS-модуль.

Метод `apply` глобального объекта `BEMHTML` может быть вызван в любом JavaScript-окружении, как на сервере, так и на клиенте.


<a name="fs"></a>
#### Подключение бандла BEMTREE

При подключении рантайма BEMTREE с помощью YModules или в виде CommonJS-модуля в некоторых проектах возможно возникновение ошибки. Причина ее в отсутствии объекта `Vow`в глобальном контексте технологией BEMTREE.

В последующих версиях `bem-core` ошибка будет устранена. Пока же требуется выполнить рантайм технологии BEMTREE в модифицированном контексте, содержащем нужные объекты.

Для этого сначала нужно установить в проекте npm-пакет Vow:

```
$ npm i vow
```


Вместо того, чтобы подключить рантайм бандл BEMTREE как CommonJS-модуль, воспользуемся `fs` – стандартным модулем NodeJS, чтобы сохранить содержимое бандла в переменную:

```js
// подключаем модули
var FS = require('fs'),
    VM = require('vm'),
    Vow	= require('vow'),

// считываем из каталога /desktop.bundles/index/ файл бандла BEMTREE
bemtreeTemplate = FS.readFileSync('./desktop.bundles/index/index.bemtree.js', 'utf-8'),

// создаем объект контекста context с помощью метода createContext
context = VM.createContext({
    console: console,
    Vow: Vow
});

// выполняем сценарий из бандла BEMTREE в контексте, модифицированном объектом context
VM.runInContext(bemtreeTemplate, context);
BEMTREE = context.BEMTREE;
```

Результатом выполнения рантайма в модифицированном контексте будет полностью сформированный объект BEMTREE, содержащий все нужные для работы технологии свойства.


**NB** Пакет `vm` позволяет выполнить рантайм технологии BEMTREE в модифицированном контексте.


<a name="bemapply"></a>
### Метод apply объектов BEMHTML и BEMTREE

В свойствах объектов BEMHTML и BEMTREE, вне зависимости от способа подключения бандла, присутствует метод `apply`:
* `BEMHTML.apply()` для технологии BEMHTML;
* `BEMTREE.apply()` для технологии BEMTREE.

Метод `apply` инициирует процесс шаблонизации.
Аргументом он принимает фрагмент БЭМ-дерева в формате BEMJSON, для которого осуществляется шаблонизация.

Метод `apply` объекта BEMTREE – асинхронный. Резульатом его выполнения
будет [vow](https://github.com/dfilatov/vow)-промис. Поэтому, чтобы
получить сформированный BEMJSON для следующего этапа шаблонизации,
нужно воспользоваться методом `.then()`. Этот метод дожидается
разрешения промиса, а затем передает результат в качестве аргумента в callback-функцию.

В упрощенном виде двухэтапная шаблонизация может быть реализована так:

```js
BEMTREE.apply({ block: 'intitial' })
	.then(function(bemjson) {
		var html = BEMHTML.apply(bemjson);
	});
  ```

При этом BEMTREE-шаблон блока `initial` может содержать ссылки на другие БЭМ-сущности. Тогда шаблонизатор рекурсивно вызовет BEMTREE-шаблоны, на которые он ссылался.

**NB** Объекты BEMHTML и BEMTREE используются только для запуска процесса шаблонизации и не содержат каких-либо полезных свойств, кроме метода `apply`.



<a name="links"></a>
## Смотрите также
### Технологии
* [BEMTREE](https://ru.bem.info/technology/bemtree/current/bemtree/)
* [BEMHTML](https://ru.bem.info/technology/bemhtml/current/reference/)
* [BEMJSON](https://ru.bem.info/technology/bemjson/current/bemjson/)

### Примеры
* [Примеры и рецепты BEMTREE](https://ru.bem.info/technology/bemtree/current/bemtree/#examples)
* [Примеры и рецепты BEMHTML](https://ru.bem.info/technology/bemhtml/current/reference/#examples)

### В сообществе
* Мастер-класс [Динамический БЭМ-сайт на Node.js](https://tech.yandex.ru/events/bemup/29-november-2013/talks/1413/)
* [BEMTREE — генерируй дерево](https://tech.yandex.ru/events/bemup/yac-bemup/talks/1354/)
