# Справочное руководство по шаблонизатору BEMHTML

<a name="intro"></a>
## Введение

**Данный документ** представляет собой справочное руководство по шаблонизатору BEMHTML.

В документе описаны:

* основные особенности BEMHTML, отличающие его от других шаблонизаторов;
* примеры решения типовых задач средствами BEMHTML.

**Целевая аудитория документа** — веб-разработчики и HTML-верстальщики, использующие
[БЭМ-методологию](https://ru.bem.info/method/).

Предполагается, что читатель знаком с:

* HTML;
* JavaScript;
* CSS;
* БЭМ;
* [BEMJSON](https://ru.bem.info/technology/bemjson/current/bemjson/).


**В документе не описаны** настройка среды разработки и процедуры компиляции шаблонов, синтаксис BEM-XJST-шаблонизаторов, синтаксис BEMJSON.

<a name="bemhtml"></a>
## Особенности шаблонизатора BEMHTML

<a name="arch"></a>
### Архитектура шаблонизатора

Для обработки BEMHTML-шаблонов используется модуль [bem-xjst](https://ru.bem.info/tools/templating-engines/bemxjst/), расширенный логикой из базового шаблона BEMHTML – [i-bem.bemhtml](https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/i-bem.bemhtml).

Специфическая для BEMHTML логика при этом реализована на уровне базового шаблона `i-bem.bemhtml`. Базовый шаблон определяет:
* набор и порядок вызова [стандартных мод](#standardmoda);
* доступные [поля контекста](#context_field)

Подробнее об особенностях архитектуры BEMHTML читайте в соответствующем разделе документа по [шаблонизации данных в bem-core](https://ru.bem.info/technology/bemhtml/current/templating/#bemx_arch).

<a name="uts"></a>
### Поддержка BEM-XJST-синтаксиса
BEMHTML – [BEM-XJST-шаблонизатор](https://ru.bem.info/technology/bemhtml/current/templating/#bemx_intro). Иначе говоря, BEMHTML использует **BEM-XJST-синтаксис** и сохраняет все особенности BEM-XJST-шаблонизаторов, такие как:
* [привязка к БЭМ-предметной области](https://ru.bem.info/technology/bemhtml/current/templating/#bem_area);
* [декларативные шаблоны](https://ru.bem.info/technology/bemhtml/current/templating/#decl_templatе);
* [язык описания и исполнения шаблонов — JavaScript](https://ru.bem.info/technology/bemhtml/current/templating/#language);
* [ограничения на уровне соглашений](https://ru.bem.info/technology/bemhtml/current/templating/#restrictions).



<a name="basic"></a>
## Основные понятия

<a name="inputdata"></a>
### Входные данные: BEMJSON

Поскольку BEMHTML основан на JavaScript, стандартным форматом представления БЭМ-дерева выбрана структура данных (объект) JavaScript, с набором дополнительных соглашений о представлении БЭМ-сущностей — BEMJSON.


Задача шаблонизатора BEMHTML — преобразовать входное БЭМ-дерево в выходной HTML-документ. В целях сохранения гибкости
и поддерживаемости, на уровне шаблонизатора не следует производить сложных преобразований входных данных. Шаблоны должны
быть максимально простыми утверждениями, сопоставляющими каждому типу БЭМ-сущности нужное HTML-оформление.

Поэтому структура входного БЭМ-дерева должна быть ориентирована на **представление** (view), чтобы при генерации
HTML-дерева не требовалось изменять набор и порядок блоков и элементов. Приведение БЭМ-дерева к такому развернутому виду должно производиться на уровне бэкенда, предшествующего шаблонизатору (например, с помощью технологии [BEMTREE](https://ru.bem.info/technology/bemtree/current/bemtree/)).

Иллюстрацией view-ориентированного формата
данных может служить пример френдленты, разобранный в разделе [Приведение входных данных к формату, ориентированному на представление](https://ru.bem.info/technology/bemtree/current/bemtree/#bringing_input) документации по BEMTREE.

В то же время детали организации HTML-страницы, которые являются зоной ответственности верстальщика, должны определяться
только на уровне шаблонизатора. Пример такого решения приведен в разделе [Добавление БЭМ-сущностей для задач верстки](#additionbem).

**См. также**:

  * [Синтаксис BEMJSON](https://ru.bem.info/technology/bemjson/current/bemjson/)


<a name="templatebemjson"></a>
### Шаблон

Единицей программы на BEMHTML является **шаблон**. Шаблон BEMHTML связывает входную БЭМ-сущность (заданную именем
сущности, элемента, именем и значением модификатора) и соответствующий этой сущности HTML-элемент.

Шаблон состоит из:

* **предиката** — набора условий, при выполнении которых применяется шаблон. Типичный предикат описывает свойства
  входной БЭМ-сущности;
* и **тела** — инструкций по генерации выходного HTML.

**См. также**:

* [Синтаксис BEM-XJST](https://ru.bem.info/technology/bemhtml/current/templating/#unity)

<a name="moda"></a>
### Мода

В процессе работы шаблонизатор последовательно обходит узлы входного БЭМ-дерева. Для каждого узла — БЭМ-сущности —
выполняется цикл генерации выходного HTML-элемента. Для вложенных сущностей цикл генерации HTML-элементов выполняется
рекурсивно. Таким образом, выходное HTML-дерево формируется поэлементно в процессе обхода входного БЭМ-дерева.

Цикл генерации каждого элемента последовательно проходит ряд фаз, называемых **модами**. Каждая мода отвечает
за определенный фрагмент генерируемого HTML-элемента — тег, атрибуты, класс и т.п. В каждой моде вызывается процедура выбора и выполнения подходящего шаблона.

Моды позволяют разделить выходной элемент на фрагменты, каждый из которых может быть описан простым типом данных:
тег и класс — строкой, атрибуты — словарем, необходимость в БЭМ-классах — логическим значением и т.п. Благодаря этому
возможно написание декларативных шаблонов, в предикате которых указана мода, а в теле содержатся данные соответствующего
этой моде простого типа. В этом случае полное представление HTML-элемента может быть задано несколькими шаблонами.

Особый статус имеет **[мода default](#default)**, которая отвечает за генерацию целого HTML-элемента. В рамках этой
моды задан набор и порядок прохождения остальных мод, соответствующих фрагментам HTML-элемента, а также определена
процедура сборки финального представления HTML-элемента из фрагментов, сгенерированных в остальных модах. Написание
шаблона, который переопределяет поведение в данной моде, позволяет полностью контролировать генерацию элемента
из BEMHTML, не пользуясь стандартными модами, позволяющими генерировать выходной элемент по частям.

**См. также**:

* [Стандартные моды](#standardmoda)

<a name="context"></a>
### Контекст

В процессе обхода входного BEMJSON-дерева шаблонизатор строит **контекст** — структуру данных, которая доступна в момент применения шаблонов. Контекст соответствует текущему элементу (узлу) входного БЭМ-дерева и включает:

* нормализованные сведения о текущей БЭМ-сущности;
* фрагмент входных данных без модификаций (текущий элемент BEMJSON-дерева и его потомки);
* строковый буфер, в который записывается HTML-результат;
* служебные поля, содержащие сведения о текущем состоянии (мода, позиция во входном БЭМ-дереве и т.п.);
* вспомогательные функции.

БЭМ-сущность, описываемая текущим контекстом, называется **контекстной сущностью**.

**См. также**:

* [Поля контекста](#context_field)
* [Достраивание БЭМ-сущностей по контексту](https://ru.bem.info/technology/bemhtml/current/templating/#extensionbem)



<a name="standardmoda"></a>
## Стандартные моды

В базовом шаблоне BEMHTML определен набор стандартных мод, которые задают порядок обхода входного БЭМ-дерева (BEMJSON) и генерации выходного HTML, используемый BEMHTML по умолчанию.

По функциональности моды разделяются на два класса:

  * **«Пустая» мода** определяет алгоритм обхода узлов входного BEMJSON и вызова остальных мод;
  * Все остальные моды определяют порядок генерации выходного HTML. В каждой из таких мод формируется тот или иной
    фрагмент выходного HTML-дерева.

Для генерации HTML в каждой моде вызывается процедура выбора и выполнения подходящего шаблона (предикат которого истинен
в данном контексте). Результат вычисления тела выбранного шаблона подставляется в тот фрагмент HTML-дерева (HTML-элемента), за генерацию которого отвечает данная мода.

Данная логика работы накладывает следующие ограничения на шаблоны:

  * Если шаблон выводит какие-то данные в HTML, в его предикате должна быть указана мода.
  * В предикате шаблона может быть указано не более одной моды.
  * В результате вычисления тела шаблона должен возвращаться тот тип объекта, который ожидается в рамках данной моды.

В последующих разделах моды перечислены в порядке их вызова при обработке элемента входного BEMJSON.

<a name="empty_moda"></a>
### «Пустая» мода (`""`)

*Тип значения тела шаблона: `не используется`*

Пустая (не определенная) мода соответствует моменту, когда значение поля контекста `this._mode` равно пустой стоке
(`""`). Это значение выставляется:

  * перед началом обработки входного дерева;
  * в момент рекурсивного вызова процедуры обхода дерева в моде `default`.

Действие, выполняемое в рамках пустой моды, зависит от типа контекстного (текущего) элемента входного BEMJSON-дерева.

<table>
<tr>
    <th>Тип элемента</th>
    <th>Действие</th>
</tr>
<tr>
    <td><b>БЭМ-сущность</b> (блок или элемент)</td>
    <td>Выставление значений в служебных полях контекста (<code>block elem mods elemMods ctx position</code>)
    и вызов шаблонов по моде <code>default</code>.</td>
</tr>

<tr>
    <th>строка/число</th>
    <td>Вывод значения, приведенного к строке, в буфер HTML-результата.</td>
</tr>
<tr>
    <th>Boolean, undefined, null</th>
    <td>Вывод пустой строки в буфер HTML-результата.</td>
</tr>
<tr>
    <th>массив</th>
    <td>Итерация по массиву с рекурсивным вызовом шаблонов по пустой моде.</td>
</tr>
</table>

Определение шаблона по пустой моде (подпредикат `mode(this._mode === "")`) имеет смысл только в том случае, если необходимо
переопределить принцип обхода входного дерева.

Вызов шаблонов по пустой моде (конструкция `apply('')` в теле шаблона) необходим, если требуется отклониться
от однозначного соответствия «входная БЭМ-сущность — выходной HTML-элемент» и сгенерировать более одного элемента на одну входную сущность. В частности, такой вызов осуществляется автоматически при использовании
[конструкции applyCtx](https://ru.bem.info/technology/bemhtml/current/templating/#applyctx).

**См. также**:

  * [Оборачивание блока в другой блок](#wrappingunit)

<a name="default"></a>
### default

*Тип значения тела шаблона: `не используется`*

В рамках моды `default` полностью формируется выходной HTML-элемент, соответствующий входной БЭМ-сущности.

В ходе выполнения моды `default` происходит:

  * вызов всех остальных стандартных мод, отвечающих за формирование отдельных аспектов HTML-элемента;
  * объединение результатов выполнения всех вызываемых мод в результирующую HTML-строку;
  * рекурсивный вызов шаблонов на результат выполнения моды `content`.

На рисунке ниже схематически отражено, в каких модах генерируются различные фрагменты выходного HTML-элемента.

![mode-default](https://raw.github.com/bem/bem-core/v1/common.docs/reference/reference_mode_default.png)

Схема отражает вариант обработки элемента, имеющего пару открывающий—закрывающий тег и вложенное содержимое. Обработка
коротких (самозакрытых) элементов аналогична и отличается только отсутствием закрывающего тега и рекурсии. Следует
ли обрабатывать данный элемент как короткий, определяет вспомогательная функция контекста `this._.isShortTag`
на основании имени элемента (тега).

Определение шаблона по моде `default` (подпредикат `def()`) необходимо в тех случаях, когда нужно переопределить
процедуру генерации выходного HTML-элемента, например, добавить DOCTYPE к тегу HTML:


```js
block ('b-page')(
  def()(function() {
    this._buf.push('<!DOCTYPE html>');
    return applyNext();
  }),
  tag()('html')
)
```


<a name="tag"></a>
### tag

* *Тип значения тела шаблона: `String`*
* *Значение по умолчанию: `` 'div' ``*

Мода `tag` задает имя выходного HTML-элемента (тег). По умолчанию имя элемента равно `div`. Фрагменты HTML, за генерацию
которых отвечает мода `tag`, выделены на рисунке:

![mode-tag](https://raw.github.com/bem/bem-core/v1/common.docs/reference/reference_mode_tag.png)


**NB** Если в качестве значения `tag` указать пустую строку, для данной сущности будет пропущен этап генерации
HTML-элемента (тега и всех атрибутов), но содержимое элемента (`content`) будет обработано обычным образом.


Определение шаблона по моде `tag` (подпредикат `tag()`) необходимо, если:

  * для данной сущности следует сгенерировать HTML-элемент с именем, отличным от `div`;
  * отказаться от генерации HTML-элемента для данной сущности, но обработать вложенные сущности.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>

<tr>
    <td>
        <pre><code>{
  block: 'b1',
  content: 'text'
}</code></pre>
    </td>
    <td><pre><code>block('b1').tag()('span')</code></pre></td>
    <td><pre><code>&lt;span class="b1"&gt;text&lt;/span&gt;</code></pre></td>
</tr>
<tr>
    <td>
        <pre><code>{
  block: 'b1',
  content: {
    block: 'b2'
  }
}</code></pre>
    </td>
    <td><pre><code>block('b1').tag()('')</code></pre></td>
    <td><pre><code>&lt;div class="b2"&gt;&lt;/div&gt;</code></pre></td>
</tr>
</table>

<a name="js"></a>
### js

* *Тип значения тела шаблона: `Boolean|Object`*
* *Значение по умолчанию: `false`*

Мода `js` указывает, есть ли у обрабатываемого блока клиентский JavaScript. В случае наличия JavaScript в моде `js`
могут быть переданы параметры клиентского JavaScript (записываются в атрибут HTML-элемента, имя которого определяется
[модой `jsAttr`](#jsAttr).

Мода `js` допускает два типа значения тела шаблона:

  * `Boolean` — Флаг, указывающий, имеет ли данный блок клиентский JavaScript.
  * `Object` — Хэш, содержащий параметры JavaScript (подразумевается, что данный блок имеет клиентский JavaScript).

Фрагменты HTML, за генерацию которых отвечает мода `js`, выделены на рисунке:

![mode-js](https://raw.github.com/bem/bem-core/v1/common.docs/reference/reference_mode_js.png)

Определение шаблона по моде `js` (подпредикат `js()`) имеет смысл только в том случае, если у блока имеется клиентский
JavaScript.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>
<tr>
    <td><pre><code>{block: 'b1'}</code></pre></td>
    <td><pre><code>block('b1').js()(true)</code></pre></td>
    <td><pre><code>&lt;div class="b1 i-bem"
    data-bem="{ 'b1': {} }"&gt;
&lt;/div&gt;</code></pre></td>
</tr>
<tr>
    <td><pre><code>{block: 'b1'}</code></pre></td>
    <td><pre><code>block('b1').js()({param: 'value'})</code></pre></td>
    <td><pre><code>&lt;div class="b1 i-bem"
    data-bem="{ 'b1': { 'param': 'value' } }"&gt;
&lt;/div&gt;</code></pre></td>
</tr>
</table>

**См. также**:

  * [JS-реализация блока i-bem](https://ru.bem.info/libs/bem-bl/current/desktop/i-bem/)

<a name="bem"></a>
### bem

* *Тип значения тела шаблона: `Boolean`*
* *Значение по умолчанию: `true`*

Мода `bem` указывает, нужно ли при формировании HTML-атрибута `class` включать автоматически сгенерированные имена
классов, описывающие данную БЭМ-сущность. По умолчанию генерация БЭМ-классов выполняется. Фрагмент HTML, за генерацию
которого отвечает мода `bem`, выделен на рисунке:

![mode-bem](https://raw.github.com/bem/bem-core/v1/common.docs/reference/reference_mode_bem.png)

Определение шаблона по моде `bem` (подпредикат `bem()`) имеет смысл только в том случае, если для данной сущности
**не нужно** генерировать HTML-классы, относящиеся к БЭМ-предметной области. Это может быть необходимо для соблюдения
синтаксических требований HTML. Например, теги `html`, `meta`, `link`, `script`, `style` не могут иметь атрибута `class`.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>
<tr>
    <td>
        <pre><code>{
  block: 'b-page'
}</code></pre>
    </td>
    <td>
        <pre><code>block('b-page')(
  tag()('html'),
  bem()(false)
)</code></pre>
    </td>
    <td><pre><code>&lt;html&gt;&lt;/html&gt;</code></pre></td>
</tr>
</table>

<a name="cls"></a>
### cls

* *Тип значения тела шаблона: `String`*
* *Значение по умолчанию: `''`*

Мода `cls` позволяет определить произвольную строку, добавляемую в значение атрибута `class` помимо автоматически
генерируемых значений. Фрагмент HTML, за генерацию которого отвечает мода `cls`, выделен на рисунке:

![mode-cls](https://raw.github.com/bem/bem-core/v1/common.docs/reference/reference_mode_cls.png)

Определение шаблона по моде `cls` (подпредикат `cls()`) имеет смысл в том случае, если для данного элемента необходимы
специфические HTML-классы, не относящиеся к предметной области БЭМ.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>
<tr>
    <td>
        <pre><code>{
  block: 'b1'
}</code></pre>
    </td>
    <td><pre><code>block('b1').cls()('custom')</code></pre></td>
    <td><pre><code>&lt;div class="b1 custom"&gt;&lt;/div&gt;</code></pre></td>
</tr>
</table>

<a name="mix"></a>
### mix

* *Тип значения тела шаблона: `Array|Object`*
* *Значение по умолчанию: `[]`*

Мода `mix` задает список БЭМ-сущностей, которые необходимо **примешать** к данной сущности. Сущность, в рамках которой
выполняется примешивание, называется **базовой**, а добавляемая сущность — **примешиваемой**. Имеет смысл примешивание
блоков и элементов.

Технически примешивание сводится к следующим операциям:

  * БЭМ-классы примешиваемой сущности добавляются в значение атрибута `class` текущего элемента наряду с классами
    базовой сущности;
  * Если примешиваемая сущность имеет JavaScript-параметры, они добавляются в значение атрибута, заданного модой
    `jsAttr`. JavaScript-параметры передаются в виде хэша, ключом является имя примешиваемой сущности.

Все прочие составляющие HTML-элемента (тег, атрибуты и под.) генерируются на основании шаблонов для базовой сущности.

Значением тела шаблона для данной моды может быть:

  * **Массив**, в котором содержится список объектов (хэшей), каждый из которых описывает БЭМ-сущности, которые
    необходимо подмешать.
  * **Объект**, описывающий примешиваемую БЭМ-сущность. Интерпретируется как массив, состоящий из одного элемента.

Фрагмент HTML, за генерацию которого отвечает мода `mix`, выделен на рисунке:

![mode-mix](https://raw.github.com/bem/bem-core/v1/common.docs/reference/reference_mode_mix.png)

Определение шаблона по моде `mix` (подпредикат `mix()`) требуется, когда необходимо выполнить примешивание блока
или элемента на уровне шаблонизатора.

***
**NB** Примешивание БЭМ-сущностей выполняется рекурсивно. Иными словами, если для примешиваемой сущности определен
шаблон, в котором к ней примешиваются еще какие-либо сущности, все такие сущности добавляются рекурсивно и классы
для них появятся в атрибуте `class` базовой сущности (см. пример ниже).


<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>
<tr>
    <td>
        <pre><code>{
  block: 'b1'
  js: { p: 1 }
}</code></pre>
    </td>
    <td>
        <pre><code>block('b1').mix()({
  block: 'b2',
  js: { p: 2 }
})</code></pre>
    </td>
    <td><pre><code>&lt;div class="b1 b2 i-bem"
    data-bem="{
        'b1': { 'p': 1 },
        'b2': { 'p': 2 }
    }"&gt;
&lt;/div&gt;</code></pre></td>
</tr>
<tr>
    <td>
        <pre><code>{
  block: 'b1'
}</code></pre>
    </td>
    <td>
        <pre><code>block('b1').mix()([ { block: 'b2' } ])
block('b2').mix()([ { block: 'b3' } ])
block('b3').mix()([ { block: 'b4' } ])
block('b4').mix()([ { block: 'b1' } ])</code></pre>
    </td>
    <td><pre><code>&lt;div class="b1 b2 b3 b4"&gt;&lt;/div&gt;</code></pre></td>
</tr>
</table>

***

<a name="jsAttr"></a>
### jsAttr

* *Тип значения тела шаблона: `String`*
* *Значение по умолчанию: `'data-bem'`*

Мода `jsAttr` определяет имя HTML-атрибута, в значении которого будут переданы параметры клиентского JavaScript для
данного блока. По умолчанию используется атрибут `data-bem`. Фрагмент HTML, за генерацию которого отвечает мода `jsAttr`,
выделен на рисунке:

![mode-jsattr](https://raw.github.com/bem/bem-core/v1/common.docs/reference/reference_mode_jsattr.png)

Определение шаблона по моде `jsAttr` (подпредикат `jsAttr()`) необходимо в том случае, если требуется передавать параметры JavaScript в нестандартном атрибуте.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>
<tr>
    <td>
        <pre><code>{
  block: 'b1',
  js: true
}</code></pre>
    </td>
    <td><pre><code>block('b1').jsAttr()('ondblclick')</code></pre></td>
    <td><pre><code>&lt;div class="b1 i-bem"
    ondblclick="{'b1': {} }"&gt;
&lt;/div&gt;</code></pre></td>
</tr>
</table>

<a name="attrs"></a>
### attrs

* *Тип значения тела шаблона: `Object`*
* *Значение по умолчанию: `{}`*

Мода `attrs` позволяет задать имена и значения произвольных HTML-атрибутов для данного элемента. По умолчанию
дополнительные атрибуты не генерируются. Фрагмент HTML, за генерацию которого отвечает мода `attrs`, выделен на рисунке:

![mode-attrs](https://raw.github.com/bem/bem-core/v1/common.docs/reference/reference_mode_attrs.png)

Значением тела шаблона для данной моды должен быть объект (хеш), содержащий имена и значения атрибутов в качестве
пар ключ—значение. В качестве ключа должен выступать валидный идентификатор HTML-атрибута, а в качестве значения — строка или число. При выводе HTML специальные символы в значениях атрибутов экранируются вспомогательной функцией `this._.attrEscape()`.


**NB** Если в качестве значения атрибута указать `undefined`, этот атрибут не будет выведен в HTML-элементе.


Определение шаблона по моде `attrs` (подпредикат `attrs()`) необходимо во всех случаях, когда требуется:

  * добавить произвольные HTML-атрибуты на уровне шаблонизатора;
  * исключить указанные атрибуты из вывода, даже если они были определены во входном BEMJSON.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>

<tr>
    <td>
        <pre><code>{
  block: 'logo',
}</code></pre>
    </td>
    <td>
        <pre><code>block('logo')(
  tag()('img'),
  attrs()({ alt: 'logo', href: 'http://...' })
)</code></pre>
    </td>
    <td><pre><code>&lt;img alt="logo"
    href="http://..." /&gt;</code></pre></td>
</tr>

<tr>
    <td>
        <pre><code>{
  block: 'input',
  disabled: true
}</code></pre>
    </td>
    <td>
        <pre><code>block('input')(
  tag()('input'),
  attrs()({
    disabled: this.ctx.disabled ? 'disabled' : undefined
  })
)</code></pre>
    </td>
    <td><pre><code>&lt;input class="input"
    disabled="disabled"/&gt;</code></pre></td>
</tr>

<tr>
    <td>
        <code>{ block: 'input' }</code>
    </td>

    <td>Тот же шаблон</td>
    <td><pre><code>&lt;input class="input"/&gt;</code></pre></td>
</tr>
</table>

<a name="content"></a>
### content

* *Тип значения тела шаблона: `BEMJSON`*
* *Значение по умолчанию: `this.ctx.content`*

В рамках моды `content` вычисляется содержимое HTML-элемента, в качестве которого может выступать произвольный BEMJSON
(как строка или число, так и дерево БЭМ-сущностей). В качестве значения по умолчанию используется значение поля
`content` контекстной БЭМ-сущности (`this.ctx.content`).

Фрагмент HTML, за генерацию которого отвечает мода `content`, выделен на рисунке:

![mode-content](https://raw.github.com/bem/bem-core/v1/common.docs/reference/reference_mode_content.png)

Определение шаблона по моде `content` (подпредикат `content()`) необходимо, если:

  * Необходимо на уровне шаблонизатора добавить содержимое для сущности, у которой отсутствует `content` во входном
    BEMJSON.
  * Необходимо подменить содержимое сущности на уровне шаблонизатора.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>

<tr>
    <td>
        <pre><code>{
  block: 'b1'
}</code></pre>
    </td>
    <td>
        <pre><code>block('b1').content()({
  block: 'b2'
})</code></pre>
    </td>
    <td><pre><code>&lt;div class="b1"&gt;&lt;div class="b2"&gt;&lt;/div&gt;&lt;/div&gt;</code></pre></td>
</tr>
</table>


**См. также**:

* [Наследование](#inheritage)
* [Добавление БЭМ-сущностей для задач верстки](#additionbem)

<a name="context_field"></a>
## Поля контекста

В процессе работы шаблонизатор BEMHTML строит структуру данных, содержащую сведения об обрабатываемом узле BEMJSON
и о состоянии процесса обработки. Помимо этого в контексте доступен ряд вспомогательных функций BEMHTML.

В момент выполнения шаблона контекст доступен в виде объекта, обозначаемого ключевым словом `this`. Обращение
к контексту возможно как в предикате, так и в теле шаблона.

Автор шаблонов имеет возможность определить любые дополнительные поля в контексте.

Все поля контекста можно разделить на две категории:

  * **Контекстно-зависимые**, значение которых изменяется в зависимости от обрабатываемого узла и фазы процесса обработки.
  * **Контекстно-независимые**, значение которых постоянно.

**См. также**:

  * [Контекст](#context)

<a name="contextdependent"></a>
### Контекстно-зависимые поля
BEMHTML расширяет набор [контекстно-зависимых полей BEM-XJST](https://ru.bem.info/technology/bemhtml/current/templating/#contextdependent) следующими:
<table>
<tr>
    <th>Поле</th>
    <th>Тип значения</th>
    <th>Описание</th>
</tr>
<tr>
    <td><code>this.position</code></td>
    <td><code>Number</code></td>
    <td>Номер позиции текущей сущности среди ее сиблингов во входном BEMJSON-дереве (начиная с 1).</td>
</tr>
<tr>
    <td><code>this._buf</code></td>
    <td><code>Array</code></td>
    <td>Буфер HTML-результата. Обычно используется только для записи готовых HTML-фрагментов с использованием метода
    <code>this._buf.push()</code>.</td>
</tr>
<tr>
    <td><code>this.isFirst()</code></td>
    <td><code>Boolean</code></td>
    <td>Проверяет, является ли данная БЭМ-сущность первой среди сиблингов во входном БЭМ-дереве..</td>
</tr>

<tr>
    <td><code>this.isLast()</code></td>
    <td><code>Boolean</code></td>
    <td>Проверяет, является ли данная БЭМ-сущность последней среди сиблингов во входном БЭМ-дереве. Подробнее
    см. <a href="#algorithmbem">Алгоритм вычисления позиции БЭМ-сущности</a>.</td>
</tr>
</table>




<a name="algorithmbem"></a>
#### Алгоритм вычисления позиции БЭМ-сущности

Позиция в БЭМ-дереве (поле контекста `this.position`) представляет собой натуральное число, соответствующее порядковому
номеру текущей (контекстной) БЭМ-сущности среди ее сиблингов в БЭМ-дереве (одноранговых сущностей).

При вычислении позиции:

  * Нумеруются только те узлы обрабатываемого BEMJSON, которые соответствуют БЭМ-сущностям, прочим узлам
    не соответствует никакой номер позиции.
  * Позиции нумеруются начиная с 1.
  * Нумерация производится в порядке обхода дерева (уплощенный список иерархического представления BEMJSON).

Пример нумерации позиций во входном БЭМ-дереве:

```js
{
  block: 'page',          // this.position === 1
  content: [
    { block: 'head' },    // this.position === 1
    'text',               // this.position === undefined
    {
      block: 'menu',      // this.position === 2
      content: [
        { elem: 'item' }, // this.position === 1
        { elem: 'item' }, // this.position === 2
        { elem: 'item' }  // this.position === 3
      ]
    }
  ]
}
```


**NB** БЭМ-дерево может быть достроено в процессе выполнения шаблонов с помощью шаблонов по моде `content` и шаблонов
по пустой моде. Такое динамическое изменение БЭМ-дерева учитывается при вычислении позиции.


Функция определения последней БЭМ-сущности среди сиблингов `this.isLast()` **не сработает** в том случае, если
в массиве, содержащем одноранговые БЭМ-сущности, последний элемент не является БЭМ-сущностью. Например:

```js
  block('b1')(
    content()([
        { block: 'b2' },
        { block: 'b3' }, // this.isLast() === false
        'text'
    ])
  )
```

Такое поведение объясняется тем, что в целях оптимизации BEMHTML не выполняет предварительного полного обхода
БЭМ-дерева. Поэтому в момент обработки блока `b3` уже известна длина массива (`b3` не является последним элементом),
но еще не известно, что последний элемент не является БЭМ-сущностью и не получит номера позиции.

На практике описанный случай некорректного срабатывания `this.isLast()` не должен порождать ошибок, так как проверка
на первую/последнюю БЭМ-сущность обычно применяется к автоматически сгенерированным спискам сущностей, в которые
не имеет смысла включать данные других типов.

<a name="context_independent"></a>
### Контекстно-независимые поля

Все контекстно-независимые поля сгруппированы в объекте `this._` и представляют собой вспомогательные функции,
используемые при работе шаблонизатора. Автор шаблонов также может пользоваться этими функциями как в теле шаблонов, так и в предикатах.

BEMHTML расширяет набор [контекстно-независимых полей BEM-XJST](https://ru.bem.info/technology/bemhtml/current/templating/#context_independent) следующими:


<table>
<tr>
    <th>Поле</th>
    <th>Тип значения</th>
    <th>Описание</th>
</tr>
<tr>
    <td><code>this._.isShortTag(String)</code></td>
    <td><code>Boolean</code></td>
    <td>Проверяет, принадлежит ли указанное имя тега к списку коротких тегов (не требующих закрывающего элемента  и рекурсивной обработки). Полный список коротких тегов:<code>area</code>, <code>base</code>, <code>br</code>, <code>col</code>, <code>command</code>, <code>embed</code>, <code>hr</code>, <code>img</code>, <code>input</code>,
    <code>keygen</code>, <code>link</code>, <code>meta</code>, <code>param</code>, <code>source</code>, <code>wbr</code>.</td>
</tr>
</table>

<a name="examples"></a>
## Примеры и рецепты


<a name="select_template"></a>
### Выбор шаблона по условию

#### Задача

Блок `b-link` встречается в двух разновидностях:

  * `{ block: 'b-link', content: 'ссылка без URL' }`
  * `{ block: 'b-link', url: '//ya.ru', content: 'ссылка с URL' }`

Необходимо по-разному оформить выходной HTML-элемент в зависимости от наличия/отсутствия поля `url` в данных блока.

#### Решение
Следует сделать проверку на наличие поля `url` подпредикатом шаблона: выражение `this.ctx.url` будет истинным, только
если поле `url` определено.

```js
block('b-link')(
  tag()('span'),
  match(function() { return this.ctx.url; })(
    tag()('a'),
    attrs()(function() { return { href: this.ctx.url }; })
  )
)
```

**Неправильно** использовать для решения этой задачи условные конструкции JavaScript в теле шаблона:

```js
block('b-link').tag()(function() { return this.ctx.url ? 'a' : 'span'; })
```

При компиляции это выражение не будет оптимизировано, что отрицательно скажется на скорости работы шаблона.

**См. также**:

  * [Синтаксис шаблонов](https://ru.bem.info/technology/bemhtml/current/templating/#template)

<a name="inheritage"></a>
### Наследование

#### Задача

На разных [уровнях переопределения](https://ru.bem.info/method/filesystem/#levels)
определены два различных шаблона на одну и ту же БЭМ-сущность (`block b1`). Каждый из шаблонов определяет своё
содержимое по моде `content`.

Необходимо на втором уровне переопределения **унаследовать** содержимое, определённое на первом уровне, и добавить
дополнительное. Требуется аналог `<xsl:apply-imports/>`.

#### Решение
В BEMHTML есть аналог `<xsl:apply-imports/>`. Реализация основывается на возможности заново запустить в шаблоне
процедуру применения шаблонов к текущему контексту (`apply()`). Таким образом можно вызвать тот шаблон, который был
определен для данного контекста (БЭМ-сущности, моды и т.п.) ранее или на другом уровне переопределения.

При вычислении выражения `apply()` возвращается результат, полученный в ходе применения ранее определенного шаблона.
Для избежания бесконечного цикла необходимо добавить подпредикат проверки наличия в контексте какого-то флага (например,
`_myGuard`), который будет выставлен при выполнении `apply()`.

```js
// шаблон на первом уровне переопределения
block('b1').content()('text1')

// шаблон на втором уровне переопределения
block('b1').match(function() { return !this._myGuard; }).content()(function() {
  return [
    apply({ _myGuard: true }),  // получаем предыдущее значение content
    'text2'
  ];
})
```

В результате применения шаблонов к блоку `b1` будет получен HTML:

```xml
<div class="b1">text1text2</div>
```

В качестве альтернативного решения можно использовать конструкцию `applyNext`, которая автоматически генерирует уникальное имя флага против
зацикливания.

```js
block('b1').content()('text1');

block('b1').content()(function() {
  return [
      applyNext(), // получаем предыдущее значение content
      'text2'
  ];
});
```

**См. также**:

  * [Конструкция applyNext](https://ru.bem.info/technology/bemhtml/current/templating/#applynext)


<a name="parentblock"></a>
### Выбор шаблона в зависимости от родительского элемента

#### Задача

Для реализации языка разметки, аналогичного DocBook, нужны разные шаблоны для блока `para` в зависимости от контекста, в котором встречается данный блок. В частности, если блок `para` вложен в блок `listitem`, для него не нужно генерировать тег `<p>`.

#### Решение

В BEMHTML (а точнее, в XJST) нет неявного сохранения контекста для использования в предикатах — это сделано из соображений производительности.

Чтобы реализовать в BEMHTML контекстную зависимость, необходимо явным образом сохранить информацию о контексте, которая потребуется при обработке вложенных блоков.

Сохранение информации о контексте нужно реализовать в шаблоне для блока `listitem`. Используем флаг `inListItem`:

```js
block('listitem').match(function() { return !this.inListItem; })(function() { return apply({ inListItem: true }); });
```

Обратите внимание, на подпредикат `!this.inListItem`, позволяющий избежать зацикливания при рекурсивном вызове процедуры применения шаблонов в модифицированном контексте (`apply({inListItem:true})`).

Для обработки `para`, вложенного в `listitem`, достаточно проверить наличие в контексте флага `inListItem`.

```js
block('para').match(function() { return this.inListItem; }).tag()('');
```

Пустая строка в качестве значения шаблона по моде `tag` означает — не генерировать HTML-элемента для этого блока.


<a name="wrappingunit"></a>
### Оборачивание блока в другой блок

#### Задача

Необходимо вложить блок (`b-inner`) в другой блок (`b-wrapper`) при выполнении шаблона. Таким образом, одному входному
блоку будет соответствовать два вложенных друг в друга блока.

#### Решение

При обработке блока `b-inner` в шаблоне по моде `default` (генерация целого элемента) следует модифицировать фрагмент
входного дерева `this.ctx` (добавить блок `b-wrapper`).  Для этого используется конструкция `applyCtx()`, которая присваивает `this.ctx` и применяет шаблоны по пустой моде.



```js
block('b-inner').def()(function() {
    return applyCtx({ block: 'b-wrapper', content: this.ctx });
});
```

Для избежания бесконечного цикла необходимо при вызове выражения `applyCtx()` проверять наличие в контексте специального флага (`_wrapped`), который будет выставлен при выполнении `applyCtx()`.


**NB** Конструкцию `applyCtx()` можно применять для **замены** БЭМ-сущности в исходном дереве, если не использовать
исходное содержимое блока (`this.ctx`) в аргументе `applyCtx()`.


**См. также**:

  * [Конструкция applyCtx](https://ru.bem.info/technology/bemhtml/current/templating/#applyctx)

<a name="additionbem"></a>
### Добавление БЭМ-сущностей для задач вёрстки

#### Задача

Необходимо сверстать блок с закруглёнными уголками, работающий во всех браузерах (без использования CSS3).

Входной BEMJSON может быть таким:

```js
{ block: 'box', content: 'text' }
```

Реализация уголков требует добавления к блоку четырех дополнительных элементов. Поскольку данные элементы отражают
детали HTML-верстки, ими не следует загромождать входное БЭМ-дерево. Добавить эти элементы следует на уровне
BEMHTML-шаблона. Финальное БЭМ-дерево должно выглядеть так:

```js
{
    block: 'box',
    content: {
        elem: 'left-top',
        content: {
            elem: 'right-top',
            content: {
                elem: 'right-bottom',
                content: {
                    elem: 'left-bottom',
                    content: 'text'
                }
            }
        }
    }
}
```


#### Решение

Для модификации входного БЭМ-дерева на уровне BEMHTML потребуется написать шаблон по моде `content` для блока `box`.
Подмена фрагмента входного БЭМ-дерева (добавление необходимых элементов) выполняется с помощью конструкции `applyCtx()`,
а подстановка исходного содержимого — с помощью конструкции `applyNext()`.

BEMHTML-шаблон, выполняющий это преобразование:

```js
block('box').content()(function() {
  return applyCtx({
    elem: 'left-top',
      content: {
          elem: 'right-top',
          content: {
              elem: 'right-bottom',
              content: {
                  elem: 'left-bottom',
                  content: applyNext()
              }
          }
      }
  });
});
```

**NB** Хеш с переменной `ctx._processed` в значении `true` передается методу `applyCtx` первым параметром, чтобы выполнить метод в модифицированном контексте.



**См. также**:

  * [Конструкция apply](https://ru.bem.info/technology/bemhtml/current/templating/#apply)
  * [Конструкция applyNext](https://ru.bem.info/technology/bemhtml/current/templating/#applynext)
  * [Конструкция applyCtx](https://ru.bem.info/technology/bemhtml/current/templating/#applyctx)

<a name="use_bem"></a>
### Использование позиции БЭМ-сущности

#### Задача

Необходимо пронумеровать пункты меню, начиная с 1. В текст каждого элемента меню нужно добавить его порядковый номер
с точкой.

#### Решение

Используем механизм вычисления позиции БЭМ-сущности среди сиблингов (поле контекста `this.position`).
Входные данные могут выглядеть так:

```js
{
  block: 'menu',
  content: [
    { elem: 'item', content: 'aaa' },
    { elem: 'item', content: 'bbb' },
    { elem: 'item', content: 'ccc' }
  ]
}
```

Для выполнения нумерации следует написать шаблон по моде `content` на пункт меню, в котором содержание элемента будет
составлено из номера позиции, разделителя (точки с пробелом) и исходного текста элемента (полученного с помощью
конструкции `applyNext()`):

```js
block('menu')(
  tag()('ul'),
  elemMatch('item')(
    tag()('li'),
    content()(function() {
      return [
        this.position, '. ',
        applyNext()
      ];
    })
));
```

**См. также**:

  * [Мода content](#content)
  * [Конструкция applyNext](https://ru.bem.info/technology/bemhtml/current/templating/#applynext)

<a name="check_predicate"></a>
### Проверка подпредикатов в определенном порядке

#### Задача

Необходимо проверять подпредикаты шаблона в строго определенном порядке, например, сначала проверить наличие в контексте
объекта `this.world`, а затем проверить значение поля в этом объекте `this.world.answer`.

#### Решение

Воспользуемся тем, что подпредикат шаблона BEMHTML может быть произвольным JavaScript-выражением и запишем его
в следующей форме:

```js
match(function() { return this.world && this.world.answer === 42; })
```

Недостаток этого решения в том, что при компиляции это выражение не будет оптимизировано, что отрицательно скажется
на скорости работы шаблона. В большинстве случаев можно и нужно избегать необходимости в строгом порядке проверки
подпредикатов.

<a name="binding_html"></a>
### Связывание HTML-элементов по id

#### Задача

Необходимо для входного блока `input` сгенерировать пару HTML-элементов `<label>` и `<input>`, так чтобы значение
атрибута `input@id` было сгенерировано автоматически, уникально и совпадало со значением атрибута `label@for`.

Входные данные могут выглядеть так:

```js
{
  block: 'input',
  label: 'My Input',
  content: 'my value'
}
```

#### Решение

Для генерации уникального идентификатора, подходящего в качестве значения атрибута `id`, воспользуемся вспомогательной
функцией контекста `this.generateId()`. Чтобы сгенерировать два HTML-элемента на основании одного входного блока, потребуется два шаблона:

  * шаблон по моде `tag`, указывающий пустую строку, чтобы отменить генерацию HTML-элемента для данного блока,
    но обработать содержимое;
  * шаблон по моде `content`, в котором будут сформированы два необходимых элемента и их атрибуты.

```js
block('input')(
  tag()(''),
  content()(function() {
    return [
      {
        tag: 'label',
        attrs: { 'for': this.generateId() },
        content: this.ctx.label
      },
      {
        tag: 'input',
        attrs: {
          id: this.generateId(),
          value: this.ctx.content
        }
      }
    ];
  })
);
```


<a name="links"></a>
###Смотрите также
* [Примеры и рецепты BEMTREE](https://ru.bem.info/technology/bemtree/current/bemtree/#examples)
* Мастер-класс [Динамический БЭМ-сайт на Node.js](https://tech.yandex.ru/events/bemup/29-november-2013/talks/1413/)
* [Шаблонизация данных в bem-core](https://ru.bem.info/technology/bemhtml/current/templating/)
* [BEMTREE](https://ru.bem.info/technology/bemtree/current/bemtree/)
* [BEMJSON](https://ru.bem.info/technology/bemjson/current/bemjson/)

